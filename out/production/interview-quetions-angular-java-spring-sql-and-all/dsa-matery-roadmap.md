# DSA Mastery Roadmap

This document outlines the core "evergreen" problem-solving techniques in Data Structures & Algorithms (DSA) that transcend languages, problem statements, and company styles. Mastering these techniques will enable you to tackle any problem at Google-level and beyond.

---

## I. Foundational Problem-Solving Mindset

Before diving into techniques, build a strong foundation with these fundamentals:

### 1. Big-O Analysis (Time & Space Complexity)
Understand how to analyze and optimize algorithm efficiency.

### 2. Recursion & Recurrence Relations
Master recursive thinking and solve recurrence relations for complexity analysis.

### 3. Mathematical Proofs & Patterns (Induction, combinatorics, number theory basics)
Use proofs to validate algorithms and identify patterns in problems.

---

## II. Core Algorithmic Techniques (The "Weapons Arsenal")
These are the essential algorithmic techniques to master:

### 1. Two Pointers Technique
- Variants: Opposite ends, same direction, sliding window, partitioning.
- **Example Problems:** Pair sum, container with most water, removing duplicates, palindrome checking.

### 2. Sliding Window
- Fixed-size and variable-size windows.
- **Example Problems:** Maximum sum subarray, longest substring without repeating characters.

### 3. Binary Search & Variants
- Applied to arrays, answers, search spaces, and monotonic functions.
- **Example Problems:** Search insert position, find peak element, min/max optimization.

### 4. Sorting & Searching Patterns
- **Algorithms:** Merge sort, quicksort, counting sort.
- **Applications:** Interval problems, sweep line.

### 5. Prefix Sum / Cumulative Sum
- 1D and 2D variants.
- **Example Problems:** Range queries, subarray sums, difference arrays.

### 6. Hashing Techniques
- Use HashMap and HashSet for O(1) lookups.
- **Example Problems:** Two sum, frequency counting, grouping.

### 7. Greedy Algorithms
- Identify locally optimal choices that lead to globally optimal solutions.
- **Example Problems:** Interval scheduling, coin change, Huffman coding.

### 8. Divide & Conquer
- Break problems into smaller subproblems.
- **Example Problems:** Binary search, mergesort, quickselect, matrix exponentiation.

### 9. Recursion to Iteration Conversion
- Convert recursive solutions to iterative ones using stacks, queues, or tail recursion.
- **Example Problems:** DFS (stack), BFS (queue), tail recursion optimization.

### 10. Backtracking
- Explore all possible solutions systematically.
- **Example Problems:** N-Queens, Sudoku solver, permutations, combinations.

---

## III. Core Data Structure Mastery

Mastery of these data structures is critical:

### 11. Linked Lists
- **Operations:** Reverse, detect cycles, merge K sorted lists.

### 12. Stacks & Queues
- Monotonic stack, deque optimization.
- **Example Problems:** Valid parentheses, next greater element.

### 13. Trees (Binary, BST, Heap)
- **Traversals:** DFS (preorder, inorder, postorder), BFS.
- **Example Problems:** Lowest common ancestor, segment tree, Fenwick tree.

### 14. Graph Algorithms
- **Algorithms:** BFS, DFS, Dijkstra, Bellman-Ford, Floyd-Warshall, Union-Find.
- **Example Problems:** Shortest path, connected components, minimum spanning tree.

### 15. Heap / Priority Queue Usage
- **Example Problems:** Top-K problems, merge sorted lists, scheduling.

---

## IV. Advanced / Optimization Patterns

These techniques are for tackling edge cases and complex problems:

### 16. Dynamic Programming (DP)
- **Approaches:** Memoization vs. Tabulation.
- **Example Problems:** Knapsack, DP on grids, subsequence DP, bitmask DP.

### 17. Bit Manipulation
- **Techniques:** XOR tricks, subset generation, masks.
- **Example Problems:** Single number, power set.

### 18. Disjoint Set Union (Union-Find)
- **Example Problems:** Connected components, Kruskal’s minimum spanning tree.

### 19. Segment Trees / Fenwick Trees (BIT)
- **Example Problems:** Range queries, range updates.

### 20. Meet in the Middle
- **Example Problems:** Subset sum, half-enumeration.

### 21. Matrix Exponentiation
- **Example Problems:** Fibonacci sequence, linear recurrences.

### 22. String Algorithms
- **Algorithms:** KMP, Z-Algorithm, Rabin-Karp, Manacher’s.
- **Example Problems:** Pattern matching, longest palindromic substring.

---

## V. Meta Skills

These skills tie everything together and enable you to tackle unfamiliar problems:

### 23. Problem Decomposition & Reduction
Convert unfamiliar problems to known patterns.

### 24. Mathematical Insight
- **Concepts:** GCD/LCM, modular arithmetic, combinatorics.

### 25. Invariants & Monotonicity
Use to optimize solutions and prove correctness.

---

## Mastery Rule

- Master techniques **1–15** to solve 80–90% of top-company problems.
- Techniques **16–25** will make you *truly elite* for Google/Facebook-level edge cases.
