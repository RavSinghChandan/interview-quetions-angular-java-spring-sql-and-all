Locked ðŸ‘
Starting from **Topic 1** exactly as agreed.

---

## ðŸ“„ **File name:** `java-core-dsa.md`

# **DSA Questions â€“ Java Language Core (Primitives & Evaluation Semantics)**

---

### **DSA 1** â€” Rule break: `Math.abs` fails for `Integer.MIN_VALUE`

```java
System.out.println(Math.abs(Integer.MIN_VALUE));
```

**Answer:**
`-2147483648`

**Explanation:**
`Math.abs()` breaks for `Integer.MIN_VALUE`â€”`+2^31` cannot be represented in `int`. The "abs returns non-negative" rule fails.

---

### **DSA 2** â€” Rule break: Division by zeroâ€”int vs double behave differently

```java
System.out.println(1 / 0);
System.out.println(1.0 / 0);
```

**Answer:**
```
ArithmeticException
Infinity
```

**Explanation:**
Integer division by zero throws; floating-point returns `Infinity`. Same operator, different rules.

---

### **DSA 3** â€” Rule break: `NaN` breaks reflexivity (`x == x`)

```java
System.out.println(Double.NaN == Double.NaN);
System.out.println(Double.isNaN(Double.NaN));
```

**Answer:**
```
false
true
```

**Explanation:**
`NaN != NaN` by IEEE-754. Reflexivity (x == x) breaks for NaN.

---

### **DSA 4** â€” Rule break: Compound assignment silently narrows

```java
byte b = 10;
b += 1000;
System.out.println(b);
```

**Answer:**
`-14`

**Explanation:**
`+=` performs implicit cast; `byte b = 1000` would fail, but `b += 1000` compiles and overflows silently.

---

### **DSA 5** â€” Rule break: Ternary operator type promotion

```java
Object o = true ? Integer.valueOf(1) : Double.valueOf(2.0);
System.out.println(o.getClass().getSimpleName());
```

**Answer:**
`Double`

**Explanation:**
Ternary promotes to common numeric type; Integer is widened to Double. The "obvious" type breaks.

---

### **DSA 6** â€” Rule break: Unary minus overflow on MIN_VALUE

```java
int x = Integer.MIN_VALUE;
System.out.println(-x);
System.out.println(-x == Integer.MIN_VALUE);
```

**Answer:**
```
-2147483648
true
```

**Explanation:**
`-Integer.MIN_VALUE` overflows back to `Integer.MIN_VALUE`. Negation is not an involution.

---

### **DSA 7** â€” Rule break: Shift operatorsâ€”signed vs unsigned

```java
System.out.println(-1 >> 1);
System.out.println(-1 >>> 1);
```

**Answer:**
```
-1
2147483647
```

**Explanation:**
`>>` sign-extends; `>>>` zero-fills. "Right shift divides by 2" breaks for signed negative numbers.

---

### **DSA 8** â€” Rule break: Post-increment in array assignment

```java
int[] a = {1, 2, 3};
int i = 0;
a[i++] = i;
System.out.println(a[0] + "," + a[1]);
```

**Answer:**
`1,1`

**Explanation:**
LHS `i++` evaluates first (index 0); RHS `i` is 1. Assignment is `a[0] = 1`. Side-effect order breaks "read same variable consistently."

---

### **DSA 9** â€” Rule break: `&` vs `&&`â€”no short-circuit, NPE on null

```java
Boolean b = null;
if (b != null & b) { }
```

**Answer:**
`NullPointerException`

**Explanation:**
`&` evaluates both operands. Even when `b != null` is false, `b` is evaluated and unboxing null throws NPE.

---

### **DSA 10** â€” Rule break: Integer cache boundary

```java
Integer a = 128;
Integer b = 128;
System.out.println(a == b);
Integer c = 127;
Integer d = 127;
System.out.println(c == d);
```

**Answer:**
```
false
true
```

**Explanation:**
Cache range -128 to 127 is mandatory. Outside that, `==` compares references; equality of boxed values is not guaranteed by `==`.

---

### **DSA 11** â€” Rule break: `byte b = b + 1` vs `b += 1`

```java
byte b = 10;
// b = b + 1;  // Compile error
b += 1;
System.out.println(b);
```

**Answer:**
`11`

**Explanation:**
`b + 1` is `int`; assignment to byte requires cast. `b += 1` has implicit castâ€”same intent, different rules.

---

### **DSA 12** â€” Rule break: Integer division truncation direction

```java
System.out.println(-7 / 2);
System.out.println(-7 % 2);
```

**Answer:**
```
-3
-1
```

**Explanation:**
Java truncates toward zero. Some languages truncate toward negative infinity; remainder sign follows dividend. Rule "a/b*b + a%b == a" holds but sign of % can surprise.

---

When you're ready, send **`2`** and I'll generate **Topic 2 â€“ Method Resolution & Overloading** with the same strict format and a simple file name.
