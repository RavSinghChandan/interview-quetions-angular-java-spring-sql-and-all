Locked âœ…
Proceeding with **Topic 11** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-streams-dsa.md`

# ğŸ§  **DSA Questions â€“ Java 8+ Functional Features (Streams & Lambdas)**

*(Senior Backend | Barclays / Enterprise Java)*

> âš ï¸ Focus: **lazy evaluation, side effects, correctness, and performance**.

---

## ğŸ¯ DSA 1 â€” Streams are lazy

```java
Stream<Integer> s = Stream.of(1, 2, 3).filter(x -> {
    System.out.println(x);
    return x > 1;
});
```

**Answer:**

```
Nothing is printed
```

**Explanation:**
Streams do nothing until a **terminal operation** is invoked.

---

## ğŸ¯ DSA 2 â€” Terminal operation triggers execution

```java
Stream.of(1, 2, 3)
      .filter(x -> {
          System.out.println(x);
          return x > 1;
      })
      .count();
```

**Answer:**

```
1
2
3
```

**Explanation:**
`count()` is terminal; it triggers evaluation of the pipeline.

---

## ğŸ¯ DSA 3 â€” Order of execution

```java
Stream.of(1, 2, 3)
      .map(x -> {
          System.out.print("m" + x + " ");
          return x * 2;
      })
      .filter(x -> {
          System.out.print("f" + x + " ");
          return x > 2;
      })
      .findFirst();
```

**Answer:**

```
m1 f2 m2 f4
```

**Explanation:**
Streams process **element by element**, not stage by stage.

---

## ğŸ¯ DSA 4 â€” Short-circuiting operation

```java
Stream.of(1, 2, 3, 4)
      .filter(x -> {
          System.out.print(x + " ");
          return x > 2;
      })
      .findFirst();
```

**Answer:**

```
1 2 3
```

**Explanation:**
`findFirst()` short-circuits once a match is found.

---

## ğŸ¯ DSA 5 â€” map vs flatMap

```java
Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4))
      .map(List::stream)
      .count();
```

**Answer:**

```
2
```

**Explanation:**
`map` produces a stream of streams.

---

## ğŸ¯ DSA 6 â€” flatMap behavior

```java
Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4))
      .flatMap(List::stream)
      .count();
```

**Answer:**

```
4
```

**Explanation:**
`flatMap` flattens nested streams.

---

## ğŸ¯ DSA 7 â€” Side effects (dangerous)

```java
List<Integer> list = new ArrayList<>();
Stream.of(1, 2, 3).forEach(list::add);
System.out.println(list);
```

**Answer:**

```
[1, 2, 3]
```

**Explanation:**
Side effects work here, but are discouraged in streams.

---

## ğŸ¯ DSA 8 â€” Parallel stream side effect bug

```java
List<Integer> list = new ArrayList<>();
Stream.of(1, 2, 3, 4).parallel().forEach(list::add);
System.out.println(list.size());
```

**Answer:**

```
Unpredictable
```

**Explanation:**
`ArrayList` is not thread-safe; race conditions occur.

---

## ğŸ¯ DSA 9 â€” Correct parallel collection

```java
List<Integer> list =
    Stream.of(1, 2, 3, 4)
          .parallel()
          .collect(Collectors.toList());
System.out.println(list.size());
```

**Answer:**

```
4
```

**Explanation:**
Collectors handle synchronization internally.

---

## ğŸ¯ DSA 10 â€” Order vs performance

```java
Stream.of(1, 2, 3, 4)
      .parallel()
      .forEach(System.out::print);
```

**Answer:**

```
Order not guaranteed
```

**Explanation:**
`forEach` does not preserve encounter order in parallel streams.

---

## ğŸ¯ DSA 11 â€” Preserving order

```java
Stream.of(1, 2, 3, 4)
      .parallel()
      .forEachOrdered(System.out::print);
```

**Answer:**

```
1234
```

**Explanation:**
`forEachOrdered` preserves order but may reduce performance.

---

## ğŸ¯ DSA 12 â€” Reduce identity trap

```java
int result =
    Stream.of(1, 2, 3)
          .reduce(10, Integer::sum);
System.out.println(result);
```

**Answer:**

```
16
```

**Explanation:**
Identity value is included in the reduction.

---

## ğŸ¯ DSA 13 â€” Reduce without identity

```java
Optional<Integer> result =
    Stream.of(1, 2, 3).reduce(Integer::sum);
System.out.println(result.get());
```

**Answer:**

```
6
```

**Explanation:**
Without identity, result is wrapped in `Optional`.

---

## ğŸ¯ DSA 14 â€” Stream reuse error

```java
Stream<Integer> s = Stream.of(1, 2, 3);
s.count();
s.count();
```

**Answer:**

```
IllegalStateException
```

**Explanation:**
Streams can be consumed **only once**.

---

## ğŸ¯ DSA 15 â€” Infinite stream guard

```java
Stream.iterate(1, x -> x + 1)
      .limit(3)
      .forEach(System.out::print);
```

**Answer:**

```
123
```

**Explanation:**
`limit()` prevents infinite execution.

---

## ğŸŒŸ Why this topic matters

* Prevents **hidden performance bugs**
* Avoids **parallel stream disasters**
* Shows understanding of **functional execution model**
* Interviewers expect calm reasoning here

---

### â–¶ï¸ Next step

Reply with **`12`** to continue:

## ğŸ”¥ **Optional (Senior API Design Awareness)**
