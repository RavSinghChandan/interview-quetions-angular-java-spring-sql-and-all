Locked âœ…
Proceeding with **Topic 11** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-streams-dsa.md`

# ğŸ§  **DSA Questions â€“ Java 8+ Streams & Functional Features**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ Focus: **lazy evaluation, side effects, correctness, and performance**.

---

## ğŸ¯ DSA 1 â€” Rule break: Stream consumed onceâ€”reuse throws

```java
Stream<Integer> s = Stream.of(1, 2, 3);
s.count();
s.count();  // IllegalStateException
```

**Answer:**

```
IllegalStateException
```

**Explanation:**
Stream is single-use; terminal consumes it. Rule "Stream is reusable" breaks.

---

## ğŸ¯ DSA 2 â€” Rule break: Side effects in streamâ€”order non-deterministic

```java
List<Integer> list = new ArrayList<>();
Stream.of(1, 2, 3).parallel().forEach(list::add);
System.out.println(list);
```

**Answer:**

```
Race condition; may miss elements or throw
```

**Explanation:**
forEach with side effects on non-thread-safe list; parallel breaks. Rule "forEach = safe" breaks with mutability.

---

## ğŸ¯ DSA 3 â€” Rule break: `reduce` identity must be identity

```java
Stream.of(1, 2, 3).reduce(1, (a, b) -> a * b);
```

**Answer:**

```
6 (correct here, but 1 is identity for *)
```

**Explanation:**
Wrong identity: reduce(0, (a,b) -> a*b) returns 0 always. Rule "reduce combines" breaks when identity is wrong.

---

## ğŸ¯ DSA 4 â€” Rule break: `map` can return nullâ€”NPE downstream

```java
Stream.of("a", "b").map(s -> null).collect(Collectors.toList());
```

**Answer:**

```
[List of nullsâ€”OK]
Stream.of("a").map(s -> null).filter(Objects::nonNull).count();  // NPE in some impl
```

**Explanation:**
map returning null can cause NPE in collectors. Rule "map is safe" breaks when null returned.

---

## ğŸ¯ DSA 5 â€” Rule break: `flatMap` must return Streamâ€”null NPE

```java
Stream.of(1, 2).flatMap(i -> null).count();
```

**Answer:**

```
NullPointerException
```

**Explanation:**
flatMap must return non-null Stream. Rule "flatMap flattens" breaks when null returned.

---

## ğŸ¯ DSA 6 â€” Rule break: `parallel` streamâ€”ForkJoinPool.commonPool

```java
IntStream.range(0, 100).parallel().sum();
// Uses common pool; blocks other parallel streams
```

**Answer:**

```
Blocks common pool
```

**Explanation:**
Parallel streams share common ForkJoinPool. Rule "parallel = isolated" breaksâ€”shared pool.

---

## ğŸ¯ DSA 7 â€” Rule break: `limit` short-circuitsâ€”infinite stream OK

```java
Stream.iterate(0, i -> i + 1).limit(5).count();
```

**Answer:**

```
5
```

**Explanation:**
limit short-circuits; infinite stream doesn't run forever. Rule "infinite = hangs" breaks with limit.

---

## ğŸ¯ DSA 8 â€” Rule break: `sorted` is statefulâ€”buffers all elements

```java
Stream.of(3, 1, 2).sorted().findFirst();
// Must sort all before returning first
```

**Answer:**

```
1 (but all elements buffered)
```

**Explanation:**
sorted() is stateful; buffers entire stream. Rule "stream = one pass" breaks for sorted.

---

## ğŸ¯ DSA 9 â€” Rule break: `Optional.get` on emptyâ€”NoSuchElementException

```java
Optional.empty().get();
```

**Answer:**

```
NoSuchElementException
```

**Explanation:**
get() on empty throws. Rule "get returns value" breaks for emptyâ€”use orElse/orElseGet.

---

## ğŸ¯ DSA 10 â€” Rule break: `Collectors.toMap`â€”duplicate key throws

```java
Stream.of("a", "a").collect(Collectors.toMap(s -> s, s -> s));
```

**Answer:**

```
IllegalStateException (duplicate key)
```

**Explanation:**
toMap fails on duplicate keys. Rule "collect gathers" breaksâ€”use merge function.

---

## ğŸ¯ DSA 11 â€” Rule break: `Optional.orElse` always evaluated

```java
Optional.of("x").orElse(expensiveComputation());
```

**Answer:**

```
expensiveComputation() runs even when Optional has value
```

**Explanation:**
orElse evaluates argument always; orElseGet is lazy. Rule "orElse = default" breaksâ€”eager evaluation.

---

## ğŸ¯ DSA 12 â€” Rule break: `Stream.of(null)`â€”NPE

```java
Stream.of(null);
```

**Answer:**

```
NullPointerException (single null)
Stream.of("a", null, "b");  // NPE
```

**Explanation:**
Stream.of with null element throws. Rule "Stream holds elements" breaks for null.

---

## ğŸŒŸ Why this topic matters

* Streams are **everywhere** in modern Java
* Side effects and **lazy evaluation** cause subtle bugs
* Interviewers expect **correct usage patterns**

---

### â–¶ï¸ Next step

Reply with **`12`** to continue:

## ğŸ”¥ **Optional (Senior API Design)**

Same colorful `.md`, same strict DSA interview format.
