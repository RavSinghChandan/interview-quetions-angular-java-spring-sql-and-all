Locked âœ…
Proceeding with **Topic 12** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-optional-dsa.md`

# ğŸ§  **DSA Questions â€“ `Optional` (Senior API Design)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ `Optional` is simple on the surface â€” **misused badly in production**.
> Interviewers look for **design maturity**, not syntax.

---

## ğŸ¯ DSA 1 â€” Rule break: `Optional.of(null)` throws

```java
Optional<String> o = Optional.of(null);
```

**Answer:**

```
NullPointerException
```

**Explanation:**
of() rejects null. Rule "Optional holds value" breaksâ€”of() requires non-null. Use ofNullable(null).

---

## ğŸ¯ DSA 2 â€” Rule break: `Optional.get()` on empty throws

```java
Optional.empty().get();
```

**Answer:**

```
NoSuchElementException
```

**Explanation:**
get() on empty throws. Rule "get returns value" breaksâ€”use orElse/orElseGet.

---

## ğŸ¯ DSA 3 â€” Rule break: Optional as fieldâ€”serialization problem

```java
class User {
    Optional<String> name;  // Optional is not Serializable
}
```

**Answer:**

```
Serialization issues; Optional not designed for fields
```

**Explanation:**
Optional is for return types, not fields. Rule "Optional = optional value" breaks when used as fieldâ€”serialization, null semantic.

---

## ğŸ¯ DSA 4 â€” Rule break: `Optional.orElse` eagerâ€”always evaluates

```java
Optional.of("x").orElse(expensive());
```

**Answer:**

```
expensive() runs even when value present
```

**Explanation:**
orElse evaluates argument before branch. Rule "orElse = default when empty" breaksâ€”eager. Use orElseGet.

---

## ğŸ¯ DSA 5 â€” Rule break: `Optional.map` on emptyâ€”no NPE

```java
Optional.<String>empty().map(String::length);
```

**Answer:**

```
Optional.empty()
```

**Explanation:**
map on empty returns empty; no invocation. Rule "map always runs" breaks for emptyâ€”short-circuits.

---

## ğŸ¯ DSA 6 â€” Rule break: `Optional.flatMap` returning null

```java
Optional.of("x").flatMap(s -> null);
```

**Answer:**

```
NullPointerException
```

**Explanation:**
flatMap must return non-null Optional. Rule "flatMap chains" breaks when null returned.

---

## ğŸ¯ DSA 7 â€” Rule break: `Optional.equals`â€”empty equals empty

```java
Optional.empty().equals(Optional.empty());
Optional.of("x").equals(Optional.of("x"));
```

**Answer:**

```
true
true
```

**Explanation:**
Optional defines equals; empty equals empty, same value equals. Rule "Optional compare by reference" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: `Optional` in `HashMap`â€”empty as key

```java
Map<Optional<String>, Integer> map = new HashMap<>();
map.put(Optional.empty(), 1);
map.put(Optional.empty(), 2);
System.out.println(map.size());
```

**Answer:**

```
1
```

**Explanation:**
Optional.empty() is singleton; same reference. Rule "each empty is different" breaksâ€”singleton.

---

## ğŸ¯ DSA 9 â€” Rule break: `Optional.ofNullable` with null

```java
Optional<String> o = Optional.ofNullable(null);
System.out.println(o.isPresent());
```

**Answer:**

```
false
```

**Explanation:**
ofNullable(null) returns empty. Rule "of rejects null" holds; ofNullable accepts null.

---

## ğŸ¯ DSA 10 â€” Rule break: `Optional` in collectionâ€”use sparingly

```java
List<Optional<String>> list = Arrays.asList(Optional.of("a"), Optional.empty());
list.stream().filter(Optional::isPresent).map(Optional::get).collect(toList());
```

**Answer:**

```
[a]
```

**Explanation:**
Optional in collections adds overhead; often List<String> with nulls is simpler. Rule "Optional everywhere" breaksâ€”use for returns.

---

## ğŸ¯ DSA 11 â€” Rule break: `Optional.orElseThrow` without supplier

```java
Optional.empty().orElseThrow();
```

**Answer:**

```
NoSuchElementException (Java 10+)
```

**Explanation:**
orElseThrow() throws NSE when empty. Rule "orElseThrow needs supplier" breaksâ€”default throws NSE.

---

## ğŸ¯ DSA 12 â€” Rule break: `Optional.ifPresent` doesn't return value

```java
Optional.of("x").ifPresent(v -> {});
// No way to get value and handle empty in one expression
```

**Answer:**

```
ifPresent consumes; no return
```

**Explanation:**
ifPresent is void; can't chain or return. Rule "Optional replaces null checks" breaksâ€”ifPresent is limited. Use map/orElse.

---

## ğŸŒŸ Why this topic matters

* Optional is **API design** signal
* Misuse causes **overhead and confusion**
* Interviewers expect **when to use vs not**

---

### â–¶ï¸ Next step

Reply with **`13`** to continue:

## ğŸ”¥ **Java Memory & Performance Awareness**

Same colorful `.md`, same strict DSA interview format.
