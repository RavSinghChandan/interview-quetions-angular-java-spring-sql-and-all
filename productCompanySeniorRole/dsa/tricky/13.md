Locked âœ…
Proceeding with **Topic 13** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-performance-dsa.md`

# ğŸ§  **DSA Questions â€“ Java Memory & Performance Awareness**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ This topic shows whether you think about **throughput, GC pressure, and real prod costs**.

---

## ğŸ¯ DSA 1 â€” Rule break: Autoboxing in hot loopâ€”hidden allocation

```java
Map<String, Integer> map = new HashMap<>();
for (int i = 0; i < 1_000_000; i++) {
    map.merge("key", 1, Integer::sum);  // Boxes 1 each time
}
```

**Answer:**

```
~1M Integer allocations
```

**Explanation:**
Integer::sum boxes primitives. Rule "merge is efficient" breaksâ€”autoboxing pressure. Use AtomicInteger or primitive map.

---

## ğŸ¯ DSA 2 â€” Rule break: String concatenation in loopâ€”O(nÂ²) allocations

```java
String s = "";
for (int i = 0; i < 1000; i++) {
    s += i;
}
```

**Answer:**

```
~1000 String objects
```

**Explanation:**
Each += creates new String. Rule "concatenation is cheap" breaks in loops.

---

## ğŸ¯ DSA 3 â€” Rule break: `ArrayList` initial capacityâ€”resizing cost

```java
List<Integer> list = new ArrayList<>();
for (int i = 0; i < 100_000; i++) {
    list.add(i);  // Multiple resizes
}
```

**Answer:**

```
~18 resizes
```

**Explanation:**
Default capacity 10; grows 1.5x. Rule "ArrayList add is O(1) amortized" holds, but resizes add cost. Pre-size when known.

---

## ğŸ¯ DSA 4 â€” Rule break: `Stream` vs `for`â€”overhead for small collections

```java
list.stream().map(x -> x * 2).collect(toList());
// vs
for (int i = 0; i < list.size(); i++) list.set(i, list.get(i) * 2);
```

**Answer:**

```
Stream has allocation + lambda overhead; for-loop faster for small lists
```

**Explanation:**
Stream adds object/closure overhead. Rule "Stream is always better" breaks for small hot loops.

---

## ğŸ¯ DSA 5 â€” Rule break: `LinkedList` get(i)â€”O(n) per access

```java
LinkedList<Integer> list = new LinkedList<>();
for (int i = 0; i < 1000; i++) list.add(i);
for (int i = 0; i < 1000; i++) list.get(i);  // O(n) each
```

**Answer:**

```
O(nÂ²) total
```

**Explanation:**
LinkedList has no random access. Rule "List get is O(1)" breaks for LinkedList.

---

## ğŸ¯ DSA 6 â€” Rule break: `HashMap` with bad `hashCode`â€”O(n) lookup

```java
class Key { public int hashCode() { return 1; } }
Map<Key, Integer> map = new HashMap<>();
for (int i = 0; i < 10000; i++) map.put(new Key(), i);
map.get(new Key());  // O(n)
```

**Answer:**

```
Degrades to O(n)
```

**Explanation:**
All keys collide. Rule "HashMap get is O(1)" breaks.

---

## ğŸ¯ DSA 7 â€” Rule break: `subList`â€”view, not copy

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
List<Integer> sub = list.subList(0, 2);
list.add(4);
sub.get(0);  // May throw CME
```

**Answer:**

```
ConcurrentModificationException or undefined
```

**Explanation:**
subList is view; structural change to backing invalidates. Rule "subList is independent" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: `Integer` cacheâ€”128 creates new object

```java
Integer a = 127;
Integer b = 127;
Integer c = 128;
Integer d = 128;
// a == b true; c == d false
```

**Answer:**

```
Cache -128 to 127 only
```

**Explanation:**
Outside cache, == compares references. Rule "small Integers are cached" breaks at 128.

---

## ğŸ¯ DSA 9 â€” Rule break: `try-finally` in hot pathâ€”JVM cost

```java
for (int i = 0; i < 1_000_000; i++) {
    try {
        doWork();
    } finally {
        cleanup();
    }
}
```

**Answer:**

```
try-finally has minimal cost when no exception
```

**Explanation:**
No-throw try is cheap; rule "try is expensive" often breaksâ€”cost is on throw.

---

## ğŸ¯ DSA 10 â€” Rule break: `synchronized` methodâ€”entire method locked

```java
synchronized void process() {
    read();   // Lock held
    compute(); // Lock held
    write();  // Lock held
}
```

**Answer:**

```
Coarse-grained; blocks others during entire method
```

**Explanation:**
Synchronized method locks for full duration. Rule "synchronized = safe" holds but can limit throughputâ€”use finer locks.

---

## ğŸ¯ DSA 11 â€” Rule break: `String.intern` in loopâ€”PermGen/Metaspace growth

```java
for (int i = 0; i < 1_000_000; i++) {
    ("unique" + i).intern();
}
```

**Answer:**

```
Metaspace growth; possible OOM
```

**Explanation:**
intern() adds to pool; pool never shrinks. Rule "intern saves memory" breaks when overused.

---

## ğŸ¯ DSA 12 â€” Rule break: `Optional` allocationâ€”not zero-cost

```java
return Optional.of(value);  // Allocates Optional object
return value;               // No allocation
```

**Answer:**

```
Optional adds allocation
```

**Explanation:**
Optional wraps value; allocation per call. Rule "Optional is free" breaksâ€”use for API clarity, not hot path.

---

## ğŸŒŸ Why this topic matters

* High-throughput systems **feel** these costs
* GC pressure causes **latency spikes**
* Interviewers expect **allocation awareness**

---

### â–¶ï¸ Next step

Reply with **`14`** to continue:

## ğŸ”¥ **JVM & Runtime Behavior**

Same colorful `.md`, same strict DSA interview format.
