Locked âœ…
Proceeding with **Topic 13** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-performance-dsa.md`

# ğŸ§  **DSA Questions â€“ Java Memory & Performance Awareness**

*(Senior Backend | Barclays / Enterprise Java)*

> âš ï¸ This topic shows whether you think about **throughput, GC pressure, and real prod costs**.

---

## ğŸ¯ DSA 1 â€” Autoboxing allocation cost

```java
Integer x = 0;
for (int i = 0; i < 3; i++) {
    x++;
}
System.out.println(x);
```

**Answer:**

```
3
```

**Explanation:**
Each `x++` creates a **new Integer object** (autoboxing).

---

## ğŸ¯ DSA 2 â€” Primitive vs Wrapper loop

```java
int x = 0;
for (int i = 0; i < 3; i++) {
    x++;
}
System.out.println(x);
```

**Answer:**

```
3
```

**Explanation:**
No object allocation; **faster and GC-friendly**.

---

## ğŸ¯ DSA 3 â€” Wrapper cache effect

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);
```

**Answer:**

```
true
```

**Explanation:**
Integer cache range `-128..127` reuses objects.

---

## ğŸ¯ DSA 4 â€” Cache boundary cost

```java
Integer a = 200;
Integer b = 200;
System.out.println(a == b);
```

**Answer:**

```
false
```

**Explanation:**
Outside cache â†’ new heap objects.

---

## ğŸ¯ DSA 5 â€” String concatenation in loop

```java
String s = "";
for (int i = 0; i < 3; i++) {
    s = s + i;
}
System.out.println(s);
```

**Answer:**

```
012
```

**Explanation:**
Creates **multiple intermediate Strings** â†’ allocation overhead.

---

## ğŸ¯ DSA 6 â€” Optimized concatenation

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 3; i++) {
    sb.append(i);
}
System.out.println(sb.toString());
```

**Answer:**

```
012
```

**Explanation:**
Single mutable buffer â†’ fewer allocations.

---

## ğŸ¯ DSA 7 â€” Logging performance trap

```java
logger.debug("value = " + compute());
```

**Answer:**

```
compute() always executed
```

**Explanation:**
String concatenation happens **before** log-level check.

---

## ğŸ¯ DSA 8 â€” Safe logging

```java
logger.debug("value = {}", compute());
```

**Answer:**

```
compute() executed only if debug enabled
```

**Explanation:**
Parameterized logging avoids unnecessary work.

---

## ğŸ¯ DSA 9 â€” Stream vs loop overhead

```java
IntStream.range(0, 3).sum();
```

**Answer:**

```
Works, but slower than simple loop
```

**Explanation:**
Streams add abstraction overhead for small workloads.

---

## ğŸ¯ DSA 10 â€” Parallel stream misuse

```java
IntStream.range(0, 10).parallel().sum();
```

**Answer:**

```
Often slower
```

**Explanation:**
Thread management cost > computation benefit for small tasks.

---

## ğŸ¯ DSA 11 â€” Object creation pressure

```java
for (int i = 0; i < 1_000_000; i++) {
    new Object();
}
```

**Answer:**

```
High GC pressure
```

**Explanation:**
Excessive allocations increase GC frequency.

---

## ğŸ¯ DSA 12 â€” Escape analysis benefit

```java
void f() {
    Object o = new Object();
    System.out.println(o.hashCode());
}
```

**Answer:**

```
Object may not hit heap
```

**Explanation:**
JVM may **stack-allocate or eliminate** object via escape analysis.

---

## ğŸ¯ DSA 13 â€” String.intern() risk

```java
String s = new String("java").intern();
```

**Answer:**

```
Stored in String Pool
```

**Explanation:**
Excessive interning can cause **Metaspace pressure**.

---

## ğŸ¯ DSA 14 â€” Cache vs memory trade-off

```java
Map<String, Object> cache = new HashMap<>();
```

**Answer:**

```
Faster reads, higher memory usage
```

**Explanation:**
Caching trades memory for performance.

---

## ğŸ¯ DSA 15 â€” GC symptom awareness

```java
// Application pauses observed under load
```

**Answer:**

```
Possible GC pressure
```

**Explanation:**
High allocation rate â†’ frequent GC â†’ latency spikes.

---

## ğŸŒŸ Why this topic matters

* Prevents **GC storms**
* Improves **latency & throughput**
* Helps in **production debugging**
* Interviewers expect awareness, not micro-optimizations

---

### â–¶ï¸ Next step

Reply with **`14`** to continue:

## ğŸ”¥ **JVM & Runtime Behavior (High-Level)**
