Locked âœ…
Proceeding with **Topic 14** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-jvm-dsa.md`

# ğŸ§  **DSA Questions â€“ JVM & Runtime Behavior (High-Level)**

*(Senior Backend | Barclays / Enterprise Java)*

> âš ï¸ Goal: understand **why things behave the way they do at runtime** â€” not GC algorithms.

---

## ğŸ¯ DSA 1 â€” JIT warm-up effect

```java
for (int i = 0; i < 1_000_000; i++) {
    sum += i;
}
```

**Answer:**

```
Later executions are faster
```

**Explanation:**
Hot code is optimized by **JIT compilation** after warm-up.

---

## ğŸ¯ DSA 2 â€” First request slow syndrome

```java
// First API call after JVM start
```

**Answer:**

```
Slower than subsequent calls
```

**Explanation:**
Class loading + interpretation before JIT optimization.

---

## ğŸ¯ DSA 3 â€” Class loading happens once

```java
Class.forName("com.app.Service");
Class.forName("com.app.Service");
```

**Answer:**

```
Class loaded only once
```

**Explanation:**
ClassLoader loads a class a single time per ClassLoader.

---

## ğŸ¯ DSA 4 â€” Static block execution

```java
class A {
    static { System.out.println("static"); }
}
new A();
new A();
```

**Answer:**

```
static
```

**Explanation:**
Static blocks run **once at class loading time**.

---

## ğŸ¯ DSA 5 â€” Heap vs Metaspace

```java
// Creating many classes dynamically
```

**Answer:**

```
Metaspace growth
```

**Explanation:**
Class metadata lives in **Metaspace**, not heap.

---

## ğŸ¯ DSA 6 â€” OutOfMemoryError (Heap)

```java
List<Object> list = new ArrayList<>();
while (true) list.add(new Object());
```

**Answer:**

```
OutOfMemoryError: Java heap space
```

**Explanation:**
Heap exhausted due to object allocation.

---

## ğŸ¯ DSA 7 â€” OutOfMemoryError (Metaspace)

```java
// Dynamically generating classes endlessly
```

**Answer:**

```
OutOfMemoryError: Metaspace
```

**Explanation:**
Too many classes loaded; metadata memory exhausted.

---

## ğŸ¯ DSA 8 â€” StackOverflowError

```java
void f() { f(); }
f();
```

**Answer:**

```
StackOverflowError
```

**Explanation:**
Infinite recursion exhausts thread stack.

---

## ğŸ¯ DSA 9 â€” One stack per thread

```java
new Thread(() -> {}).start();
```

**Answer:**

```
New stack created
```

**Explanation:**
Each thread gets its **own stack**.

---

## ğŸ¯ DSA 10 â€” Object survives GC

```java
Object o = new Object();
System.out.println(o);
```

**Answer:**

```
Object not collected
```

**Explanation:**
Reachable objects are not eligible for GC.

---

## ğŸ¯ DSA 11 â€” Eligible â‰  collected

```java
Object o = new Object();
o = null;
```

**Answer:**

```
Eligible for GC (not guaranteed immediately)
```

**Explanation:**
GC timing is **non-deterministic**.

---

## ğŸ¯ DSA 12 â€” `System.gc()` myth

```java
System.gc();
```

**Answer:**

```
GC may or may not run
```

**Explanation:**
Itâ€™s only a **hint**, not a command.

---

## ğŸ¯ DSA 13 â€” Stop-the-world pause

```java
// Major GC triggered
```

**Answer:**

```
All application threads paused
```

**Explanation:**
Certain GC phases are **stop-the-world**.

---

## ğŸ¯ DSA 14 â€” Finalizer unpredictability

```java
protected void finalize() { }
```

**Answer:**

```
Execution not guaranteed
```

**Explanation:**
Finalizers are unreliable and deprecated.

---

## ğŸ¯ DSA 15 â€” JVM crash vs exception

```java
throw new OutOfMemoryError();
```

**Answer:**

```
Application usually unstable
```

**Explanation:**
Errors indicate serious JVM problems; recovery is unsafe.

---

## ğŸŒŸ Why this topic matters

* Explains **startup slowness**
* Helps diagnose **OOMs & crashes**
* Prevents wrong assumptions about GC
* Interviewers expect **runtime intuition**

---

### â–¶ï¸ Next step

Reply with **`15`** to finish the roadmap:

## ğŸ”¥ **Coding Style & Defensive Java (Production Readiness)**
