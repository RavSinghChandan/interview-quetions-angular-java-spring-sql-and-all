Locked âœ…
Proceeding with **Topic 14** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-jvm-dsa.md`

# ğŸ§  **DSA Questions â€“ JVM & Runtime Behavior**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ Goal: understand **why things behave the way they do at runtime** â€” not GC algorithms.

---

## ğŸ¯ DSA 1 â€” Rule break: JIT deoptimizationâ€”optimization can be reverted

```java
// After profiling, JIT may deoptimize if code path changes
```

**Answer:**

```
Deoptimization can slow down "stable" code
```

**Explanation:**
JIT can deoptimize if assumptions break. Rule "JIT always speeds up" breaks when type/profile changes.

---

## ğŸ¯ DSA 2 â€” Rule break: `System.gc()` is a hintâ€”not guaranteed

```java
Object o = new Object();
o = null;
System.gc();
// Object may still exist
```

**Answer:**

```
GC may or may not run
```

**Explanation:**
System.gc() suggests; JVM may ignore. Rule "gc() collects immediately" breaks.

---

## ğŸ¯ DSA 3 â€” Rule break: OOM can occur in different areas

```java
// Heap OOM: new byte[Integer.MAX_VALUE]
// Metaspace OOM: excessive class loading
// Stack OOM: infinite recursion
```

**Answer:**

```
Different OOM types
```

**Explanation:**
Heap, Metaspace, Stackâ€”different limits. Rule "OOM = heap full" breaks.

---

## ğŸ¯ DSA 4 â€” Rule break: Class loadingâ€”static init runs once

```java
class C {
    static { System.out.println("init"); }
}
Class.forName("C");
Class.forName("C");  // No second "init"
```

**Answer:**

```
init printed once
```

**Explanation:**
Class loaded once; static block runs once. Rule "forName runs init each time" breaks.

---

## ğŸ¯ DSA 5 â€” Rule break: Finalizationâ€”not guaranteed to run

```java
@Override
protected void finalize() { cleanup(); }
```

**Answer:**

```
finalize() may never run
```

**Explanation:**
Deprecated; JVM may skip. Rule "finalize cleans up" breaksâ€”use try-with-resources.

---

## ğŸ¯ DSA 6 â€” Rule break: Escape analysisâ€”object may not be on heap

```java
Object o = new Object();
int h = o.hashCode();
// JVM may stack-allocate or eliminate o
```

**Answer:**

```
Object may be optimized away
```

**Explanation:**
If object doesn't escape, JVM can stack-allocate or eliminate. Rule "new = heap" breaks.

---

## ğŸ¯ DSA 7 â€” Rule break: Warm-upâ€”first N iterations slow

```java
for (int i = 0; i < 10_000; i++) {
    hotMethod();  // First ~10k slower
}
```

**Answer:**

```
Interpreted then JIT compiled
```

**Explanation:**
Interpretation first; JIT kicks in after warm-up. Rule "steady performance from start" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: `-Xmx` vs actual heapâ€”not all for objects

```java
// -Xmx1g doesn't mean 1GB for objects
// Heap has Eden, Survivor, Old; not all user-allocatable
```

**Answer:**

```
Max heap â‰  available for allocation
```

**Explanation:**
Overhead for GC, metadata. Rule "Xmx = object space" breaks.

---

## ğŸ¯ DSA 9 â€” Rule break: `String` pool in heap (Java 7+)

```java
// String pool moved from PermGen to Heap (Java 7+)
// More GC pressure if many interned strings
```

**Answer:**

```
Pool in heap; affects GC
```

**Explanation:**
Pre-Java 7: PermGen. Java 7+: Heap. Rule "String pool is separate" changed.

---

## ğŸ¯ DSA 10 â€” Rule break: `SoftReference`â€”collected before OOM

```java
SoftReference<byte[]> ref = new SoftReference<>(new byte[1024*1024]);
// GC may clear when memory pressure
```

**Answer:**

```
Can be cleared under memory pressure
```

**Explanation:**
SoftRef cleared before OOM. Rule "SoftRef = cached until OOM" holds but timing undefined.

---

## ğŸ¯ DSA 11 â€” Rule break: `ThreadLocal` in poolâ€”leak if not removed

```java
ExecutorService exec = Executors.newFixedThreadPool(10);
exec.submit(() -> {
    ThreadLocal<byte[]> tl = new ThreadLocal<>();
    tl.set(new byte[1<<20]);
    // Never remove; thread reused
});
```

**Answer:**

```
Memory leak
```

**Explanation:**
Pooled threads reused; ThreadLocal persists. Rule "ThreadLocal is per-thread" holds but "per-task" breaks in pools.

---

## ğŸ¯ DSA 12 â€” Rule break: `-XX:+UseCompressedOops`â€”32-bit refs on 64-bit

```java
// With compressed oops, refs are 32-bit
// Heap limit ~32GB; above that, uncompressed
```

**Answer:**

```
Heap size affects pointer size
```

**Explanation:**
CompressedOops fails above ~32GB heap. Rule "64-bit = 64-bit refs" breaks with compression.

---

## ğŸŒŸ Why this topic matters

* Explains **runtime behavior**
* OOM and **GC tuning** in production
* Interviewers expect **high-level JVM awareness**

---

### â–¶ï¸ Next step

Reply with **`15`** to finish:

## ğŸ”¥ **Coding Style & Defensive Java**

Same colorful `.md`, same strict DSA interview format.
