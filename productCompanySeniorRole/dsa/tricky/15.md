Locked âœ…
Finishing the roadmap with **Topic 15** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-defensive-dsa.md`

# ğŸ§  **DSA Questions â€“ Coding Style & Defensive Java (Production Readiness)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ This topic shows whether you write **safe, maintainable, production-grade Java**.

---

## ğŸ¯ DSA 1 â€” Rule break: `Objects.requireNonNull` for input validation

```java
void process(String s) {
    Objects.requireNonNull(s, "s must not be null");
}
process(null);  // NPE with message
```

**Answer:**

```
NullPointerException: s must not be null
```

**Explanation:**
Fail-fast with clear message. Rule "NPE has no message" breaksâ€”requireNonNull adds one.

---

## ğŸ¯ DSA 2 â€” Rule break: Unmodifiable collectionâ€”backing still mutable

```java
List<Integer> inner = new ArrayList<>();
inner.add(1);
List<Integer> unmod = Collections.unmodifiableList(inner);
inner.add(2);
System.out.println(unmod.size());
```

**Answer:**

```
2
```

**Explanation:**
Unmodifiable is a view; mutating backing changes it. Rule "unmodifiable = immutable" breaks.

---

## ğŸ¯ DSA 3 â€” Rule break: `List.copyOf`â€”true copy, immutable

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2));
List<Integer> copy = List.copyOf(list);
copy.add(3);  // UnsupportedOperationException
list.add(3);  // copy unchanged
```

**Answer:**

```
copy is independent and immutable
```

**Explanation:**
copyOf creates new immutable list. Rule "copy = snapshot" holds; mutating original doesn't affect copy.

---

## ğŸ¯ DSA 4 â€” Rule break: Defensive copyâ€”constructor receives mutable

```java
class Period {
    private final Date start;
    Period(Date start) {
        this.start = new Date(start.getTime());  // Defensive copy
    }
}
Date d = new Date();
Period p = new Period(d);
d.setTime(0);  // p.start unchanged
```

**Answer:**

```
p.start unchanged
```

**Explanation:**
Without defensive copy, caller could mutate. Rule "final = immutable" breaks when field is mutable reference.

---

## ğŸ¯ DSA 5 â€” Rule break: `Arrays.asList`â€”fixed size, backed by array

```java
List<Integer> list = Arrays.asList(1, 2, 3);
list.add(4);  // UnsupportedOperationException
list.set(0, 10);  // OK
```

**Answer:**

```
add throws; set works
```

**Explanation:**
asList returns fixed-size; set allowed, add/remove not. Rule "List supports add" breaks.

---

## ğŸ¯ DSA 6 â€” Rule break: `BigDecimal.equals` vs `compareTo`

```java
new BigDecimal("1.0").equals(new BigDecimal("1.00"));  // false
new BigDecimal("1.0").compareTo(new BigDecimal("1.00"));  // 0
```

**Answer:**

```
equals considers scale; compareTo ignores
```

**Explanation:**
equals: scale must match. compareTo: numeric equality. Rule "equals = compareTo == 0" breaks for BigDecimal.

---

## ğŸ¯ DSA 7 â€” Rule break: `Optional` in method parameterâ€”anti-pattern

```java
void process(Optional<String> param) { }
process(Optional.of("x"));
process(null);  // NPEâ€”Optional param can be null!
```

**Answer:**

```
Optional param can be null; defeats purpose
```

**Explanation:**
Optional for parameters adds null case (param itself). Rule "Optional eliminates null" breaks when param is Optional.

---

## ğŸ¯ DSA 8 â€” Rule break: `Integer` comparison with `==`

```java
Integer a = 127;
Integer b = 127;
Integer c = 128;
Integer d = 128;
a == b;  // true
c == d;  // false
```

**Answer:**

```
Use equals for values; == for cache range only
```

**Explanation:**
== works for -128..127 due to cache. Rule "== for primitives" breaks for boxedâ€”use equals.

---

## ğŸ¯ DSA 9 â€” Rule break: `String` comparison with `==`

```java
String a = "java";
String b = new String("java");
a == b;  // false
a.equals(b);  // true
```

**Answer:**

```
Always use equals for content
```

**Explanation:**
== compares references. Rule "literals = same ref" breaks for new String. Use equals.

---

## ğŸ¯ DSA 10 â€” Rule break: Mutable defaultâ€”shared across calls

```java
void add(List<String> list, String s) {
    if (list == null) list = new ArrayList<>();  // Defensive
    list.add(s);
}
// vs
void add(String s) {
    if (items == null) items = new ArrayList<>();
    items.add(s);
}
// If items is static field with default new ArrayList(), shared!
```

**Answer:**

```
Mutable default = shared state
```

**Explanation:**
Default mutable (e.g., empty list) can be shared. Rule "default is safe" breaks for mutables.

---

## ğŸ¯ DSA 11 â€” Rule break: `clone()`â€”shallow by default

```java
class Node {
    int val;
    List<String> refs;
    public Object clone() {
        return super.clone();  // refs shared!
    }
}
```

**Answer:**

```
refs shared between original and clone
```

**Explanation:**
Object.clone() is shallow. Rule "clone = independent copy" breaks for nested mutables.

---

## ğŸ¯ DSA 12 â€” Rule break: `record` with mutable componentâ€”equality can change

```java
record R(List<String> items) {}
R r1 = new R(new ArrayList<>(List.of("a")));
R r2 = new R(new ArrayList<>(List.of("a")));
r1.equals(r2);  // trueâ€”List.equals compares content
r1.items().add("b");  // Mutate
r1.equals(r2);  // falseâ€”equality changed after mutation
```

**Answer:**

```
true, then false
```

**Explanation:**
Record equals uses component equals; List.equals compares content. Rule "equals is stable" breaks when components are mutableâ€”mutating after equals breaks consistency.

---

## ğŸŒŸ Why this topic matters

* **Production readiness** signal
* Prevents **subtle bugs**
* Interviewers expect **defensive habits**

---

### â–¶ï¸ Roadmap complete

All 15 topics done. Same format, Uber-level rule-breaking DSA questions throughout.
