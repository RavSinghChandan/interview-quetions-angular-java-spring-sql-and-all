Locked.
Proceeding with **Topic 2** exactly in the same strict format.

---

## ðŸ“„ **File name:** `java-overloading-dsa.md`

# **DSA Questions â€“ Method Resolution & Overloading (Java)**

---

### **DSA 1** â€” Rule break: `null` matches multiple references â†’ ambiguity

```java
void m(Integer i) { System.out.println("Integer"); }
void m(Long l) { System.out.println("Long"); }

m(null);
```

**Answer:**
`Compile-time error`

**Explanation:**
`null` matches both Integer and Long. No most-specific method; ambiguity. Rule "null fits any reference" breaks when multiple overloads apply.

---

### **DSA 2** â€” Rule break: No primitive widening + boxing chaining

```java
void m(Long l) { System.out.println("Long"); }

m(10);
```

**Answer:**
`Compile-time error`

**Explanation:**
Java does not allow `int â†’ long â†’ Long` in one conversion. Widening then boxing is disallowed. Rule "auto-convert when possible" breaks here.

---

### **DSA 3** â€” Rule break: Varargs vs fixed-argâ€”varargs loses

```java
void m(int i) { System.out.println("int"); }
void m(int... i) { System.out.println("varargs"); }

m(5);
```

**Answer:**
`int`

**Explanation:**
Varargs is chosen only when no fixed-arg match exists. Rule "varargs accepts any count" breaksâ€”fixed-arg wins for single argument.

---

### **DSA 4** â€” Rule break: Boxing preferred over varargs

```java
void m(Integer i) { System.out.println("Integer"); }
void m(int... i) { System.out.println("varargs"); }

m(5);
```

**Answer:**
`Integer`

**Explanation:**
Boxing (int â†’ Integer) beats varargs. Order: exact > widening > boxing > varargs. Rule "varargs is flexible" breaks.

---

### **DSA 5** â€” Rule break: `null` to Integer chosen over int

```java
void m(int i) { System.out.println("int"); }
void m(Integer i) { System.out.println("Integer"); }

m(null);
```

**Answer:**
`Integer`

**Explanation:**
`null` cannot go to primitive; only Integer applies. Rule "primitives preferred" breaks when null is passed.

---

### **DSA 6** â€” Rule break: Unboxing null at runtime â†’ NPE

```java
void m(Integer i) {
    System.out.println(i + 1);
}
m(null);
```

**Answer:**
`NullPointerException`

**Explanation:**
Overload resolution picks Integer; at runtime `i` is null and `i + 1` unboxes null â†’ NPE. Rule "compilation succeeds = safe" breaks.

---

### **DSA 7** â€” Rule break: Most-specific ruleâ€”String beats Object

```java
void m(Object o) { System.out.println("Object"); }
void m(String s) { System.out.println("String"); }

m("Java");
```

**Answer:**
`String`

**Explanation:**
String is more specific than Object. Rule "both match" breaksâ€”most specific wins.

---

### **DSA 8** â€” Rule break: Primitive widening beats boxing

```java
void m(long l) { System.out.println("long"); }
void m(Integer i) { System.out.println("Integer"); }

m(5);
```

**Answer:**
`long`

**Explanation:**
Widening (int â†’ long) is preferred over boxing (int â†’ Integer). Rule "boxing is convenient" breaks.

---

### **DSA 9** â€” Rule break: Exact match beats widening

```java
void m(char c) { System.out.println("char"); }
void m(int i) { System.out.println("int"); }

m('A');
```

**Answer:**
`char`

**Explanation:**
char is exact match; int would require widening. Exact primitive match has highest priority.

---

### **DSA 10** â€” Rule break: Generic erasureâ€”same signature after erasure

```java
void m(List<String> list) { }
void m(List<Integer> list) { }
```

**Answer:**
`Compile-time error`

**Explanation:**
After erasure both become `m(List list)`. Same raw signature â†’ overload impossible. Rule "generics add type safety" breaks for overload resolution.

---

### **DSA 11** â€” Rule break: Overriding vs overloadingâ€”return type alone

```java
class A { Number m() { return 1; } }
class B extends A { Integer m() { return 2; } }  // override
```

**Answer:**
`Compilesâ€”covariant return`

**Explanation:**
Overriding allows covariant return (Integer extends Number). Rule "same signature" holds, but return type can narrow in override.

---

### **DSA 12** â€” Rule break: Bridge methodâ€”synthetic override

```java
interface I { Object m(); }
class C implements I { public String m() { return "x"; } }
```

**Answer:**
`Compilesâ€”bridge method generated`

**Explanation:**
Compiler inserts bridge `Object m()` delegating to `String m()`. Rule "interface must be implemented exactly" breaksâ€”JVM bridges the gap.

---

Send **`3`** when ready, and I'll generate **Topic 3 â€“ Object Creation, Memory & JVM Basics** in the same format.
