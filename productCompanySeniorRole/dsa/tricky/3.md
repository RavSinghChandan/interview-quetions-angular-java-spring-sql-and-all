Perfect ğŸ‘
Starting **Topic 3**, and I'll make it **as colorful and readable as possible in `.md`**, while keeping it **strictly interview-usable**.

No `main`, no class, pure **output-based Java DSA**, senior-backend level.

---

## ğŸ“„ **File name:** `java-memory-dsa.md`

# ğŸ§  **DSA Questions â€“ Object Creation, Memory & JVM Basics (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

---

## ğŸ¯ DSA 1 â€” Rule break: `intern()` returns pooled ref, not the object

```java
String a = new String("jvm");
String b = a.intern();
System.out.println(a == b);
```

### âœ… Answer

```
false
```

### ğŸ§  Explanation

`intern()` returns the pooled reference. The heap object `a` and pooled `b` are different. Rule "intern returns canonical instance" holds, but `a` is NOT that instance.

---

## ğŸ¯ DSA 2 â€” Rule break: Integer cache boundaryâ€”128 vs 127

```java
Integer a = 128;
Integer b = 128;
Integer c = 127;
Integer d = 127;
System.out.println(a == b);
System.out.println(c == d);
```

### âœ… Answer

```
false
true
```

### ğŸ§  Explanation

Cache range -128 to 127 is mandatory. Outside that, `==` compares references. Rule "boxed equality via equals" breaks when developers assume `==` works for small values.

---

## ğŸ¯ DSA 3 â€” Rule break: `final` locks reference, not object mutability

```java
final StringBuilder sb = new StringBuilder("api");
sb.append(" service");
System.out.println(sb);
```

### âœ… Answer

```
api service
```

### ğŸ§  Explanation

`final` prevents reassignment of the reference, not mutation of the object. Rule "final means immutable" breaks for reference types.

---

## ğŸ¯ DSA 4 â€” Rule break: Autoboxing in loopâ€”allocation per iteration

```java
Integer x = 0;
for(int i = 0; i < 1000; i++) {
    x++;
}
```

### âœ… Answer

```
1000 (correct) but ~1000 Integer objects allocated
```

### ğŸ§  Explanation

Each `x++` unboxes, increments, boxes. Rule "Integer behaves like int" breaks for performanceâ€”hidden allocation pressure.

---

## ğŸ¯ DSA 5 â€” Rule break: Compile-time vs runtime String concatenation

```java
String a = "java" + "backend";
String b = "java" + (new String("backend"));
System.out.println(a == "javabackend");
System.out.println(b == "javabackend");
```

### âœ… Answer

```
true
false
```

### ğŸ§  Explanation

Compile-time constants are folded and interned. Runtime concatenation creates new heap object. Rule "same string = same reference" breaks when one is computed.

---

## ğŸ¯ DSA 6 â€” Rule break: `substring` before Java 7â€”shared char array

```java
String s = "javabackend";
String sub = s.substring(0, 4);  // Pre-Java 7 shared backing array
```

### âœ… Answer

```
Memory leak risk (pre-Java 7)
```

### ğŸ§  Explanation

Pre-Java 7, substring shared the char array. Keeping small substring prevented large string GC. Rule "substring is independent" broke.

---

## ğŸ¯ DSA 7 â€” Rule break: WeakReference GCâ€”can be collected anytime

```java
WeakReference<Object> ref = new WeakReference<>(new Object());
System.gc();
System.out.println(ref.get());
```

### âœ… Answer

```
null (or non-nullâ€”GC is non-deterministic)
```

### ğŸ§  Explanation

Weak references are collected when no strong refs exist. Rule "reference keeps object alive" breaks for WeakReference.

---

## ğŸ¯ DSA 8 â€” Rule break: Escape analysisâ€”object may not be on heap

```java
Object o = new Object();
int h = o.hashCode();
```

### âœ… Answer

```
Object may be stack-allocated or eliminated
```

### ğŸ§  Explanation

JVM can allocate on stack or optimize away if object doesn't escape. Rule "new always allocates on heap" breaks.

---

## ğŸ¯ DSA 9 â€” Rule break: `System.gc()` is a hint, not a guarantee

```java
Object o = new Object();
o = null;
System.gc();
// Object may still exist
```

### âœ… Answer

```
GC may or may not run
```

### ğŸ§  Explanation

`System.gc()` is a suggestion. Rule "calling gc() collects immediately" breaks.

---

## ğŸ¯ DSA 10 â€” Rule break: String concatenation in loopâ€”O(nÂ²) allocations

```java
String s = "";
for(int i = 0; i < 100; i++) {
    s += i;
}
```

### âœ… Answer

```
~100 intermediate String objects created
```

### ğŸ§  Explanation

Each `+=` creates new String. Rule "concatenation is cheap" breaks in loops.

---

## ğŸ¯ DSA 11 â€” Rule break: Double.valueOf cacheâ€”implementation detail

```java
Double a = 1.0;
Double b = 1.0;
System.out.println(a == b);
```

### âœ… Answer

```
Implementation-dependent (often false)
```

### ğŸ§  Explanation

Double has no mandatory cache like Integer. Rule "small boxed values are cached" breaks for Double.

---

## ğŸ¯ DSA 12 â€” Rule break: Reference equality after deserialization

```java
// Two objects deserialized with same state
// obj1.equals(obj2) may be true but obj1 == obj2 is false
```

### âœ… Answer

```
New heap objects; == always false
```

### ğŸ§  Explanation

Deserialization creates new objects. Rule "same state = same object" breaks for identity.

---

## ğŸŒŸ Why this topic is critical for Senior Backend

* Prevents **memory leaks**
* Helps with **GC pressure**
* Improves **high-throughput system performance**
* Interviewers check this to see if you **understand the JVM**

---

### â–¶ï¸ Next step

Reply with **`4`** to continue with:

## ğŸ”¥ `equals()` & `hashCode()` â€” **Production Bug Factory**

Same colorful `.md`, same strict DSA format.
