Locked âœ…
Proceeding with **Topic 4** in the **same colorful `.md` style**, **strict DSA format**, **senior-backend level**.

---

## ğŸ“„ **File name:** `java-equals-hashcode-dsa.md`

# ğŸ§  **DSA Questions â€“ `equals()` & `hashCode()` (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ This topic causes **real production bugs**.
> Interviewers use it to **separate seniors from average devs**.

---

## ğŸ¯ DSA 1 â€” Rule break: Mutable keyâ€”change after put breaks lookup

```java
Map<User, String> map = new HashMap<>();
User u = new User(1);
map.put(u, "Admin");
u.id = 2;
System.out.println(map.get(u));
System.out.println(map.get(new User(1)));
```

### âœ… Answer

```
null
null
```

### ğŸ§  Explanation

Changing fields used in `hashCode()` moves the logical bucket. Both lookups fail. Rule "key identifies entry" breaks when key mutates.

---

## ğŸ¯ DSA 2 â€” Rule break: Symmetry violationâ€”A.equals(B) â‰  B.equals(A)

```java
class A { int x; public boolean equals(Object o) { return o instanceof A && ((A)o).x == x; } }
class B extends A {}

A a = new A(); B b = new B();
System.out.println(a.equals(b));
System.out.println(b.equals(a));
```

### âœ… Answer

```
true
false
```

### ğŸ§  Explanation

`instanceof` in A makes a.equals(b) true; default B.equals uses reference. Symmetry breaks.

---

## ğŸ¯ DSA 3 â€” Rule break: Transitivity violationâ€”equals chain breaks

```java
class Point {
    int x, y;
    public boolean equals(Object o) {
        Point p = (Point)o;
        return p.x == x;  // Ignores y
    }
}
Point p1 = new Point(); p1.x=1; p1.y=2;
Point p2 = new Point(); p2.x=1; p2.y=3;
Point p3 = new Point(); p3.x=1; p3.y=4;
```

### âœ… Answer

```
p1.equals(p2) && p2.equals(p3) but !p1.equals(p3) possible if logic differs
```

### ğŸ§  Explanation

Partial field comparison can break transitivity. Rule "equals is equivalence relation" breaks.

---

## ğŸ¯ DSA 4 â€” Rule break: equals without hashCodeâ€”HashSet.contains fails

```java
class User { int id; public boolean equals(Object o) { return ((User)o).id == id; } }
Set<User> set = new HashSet<>();
set.add(new User(1));
System.out.println(set.contains(new User(1)));
```

### âœ… Answer

```
false
```

### ğŸ§  Explanation

HashSet uses hashCode() for bucket; default hashCode uses identity. Equal objects land in different buckets. Rule "equals implies same bucket" breaks.

---

## ğŸ¯ DSA 5 â€” Rule break: hashCode without equalsâ€”Map accepts "duplicates"

```java
class Key { public int hashCode() { return 1; } }
Map<Key, String> map = new HashMap<>();
map.put(new Key(), "A");
map.put(new Key(), "B");
System.out.println(map.size());
```

### âœ… Answer

```
2
```

### ğŸ§  Explanation

Same bucket, but default equals compares references. Both entries kept. Rule "same hashCode implies equals used" breaks without proper equals.

---

## ğŸ¯ DSA 6 â€” Rule break: getClass() vs instanceofâ€”Liskov breaks

```java
class A { public boolean equals(Object o) { return o != null && o.getClass() == getClass(); } }
class B extends A {}
System.out.println(new A().equals(new B()));
```

### âœ… Answer

```
false
```

### ğŸ§  Explanation

getClass() enforces exact type. Subtype never equals supertype. Rule "subtypes can be equal" breaks.

---

## ğŸ¯ DSA 7 â€” Rule break: equals(null) must return false, not NPE

```java
class User {
    String name;
    public boolean equals(Object o) {
        return name.equals(((User)o).name);  // No null check
    }
}
new User().equals(null);
```

### âœ… Answer

```
NullPointerException (badâ€”contract says return false)
```

### ğŸ§  Explanation

Contract: `x.equals(null)` must return false. Throwing NPE breaks the contract.

---

## ğŸ¯ DSA 8 â€” Rule break: hashCode changes between put and get

```java
class Key {
    int id;
    public int hashCode() { return id; }
    public boolean equals(Object o) { return ((Key)o).id == id; }
}
Map<Key, String> map = new HashMap<>();
Key k = new Key(); k.id = 1;
map.put(k, "X");
k.id = 2;
System.out.println(map.get(k));
```

### âœ… Answer

```
null
```

### ğŸ§  Explanation

Key hash changed; lookup goes to wrong bucket. Rule "hashCode must be stable" breaks.

---

## ğŸ¯ DSA 9 â€” Rule break: Float.NaN equals itself

```java
System.out.println(Float.NaN == Float.NaN);
System.out.println(Float.valueOf(Float.NaN).equals(Float.NaN));
```

### âœ… Answer

```
false
true
```

### ğŸ§  Explanation

`==` says NaN != NaN. `Float.equals()` returns true for NaN. Rule "equals matches ==" breaks for Float/Double NaN.

---

## ğŸ¯ DSA 10 â€” Rule break: BigDecimal equals vs compareTo

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("1.00");
System.out.println(a.equals(b));
System.out.println(a.compareTo(b) == 0);
```

### âœ… Answer

```
false
true
```

### ğŸ§  Explanation

equals() considers scale; compareTo() ignores it. Rule "numerically equal implies equals" breaks.

---

## ğŸ¯ DSA 11 â€” Rule break: Record equalsâ€”all components matter

```java
record Point(int x, int y) {}
Point p1 = new Point(1, 2);
Point p2 = new Point(1, 2);
System.out.println(p1.equals(p2));
```

### âœ… Answer

```
true
```

### ğŸ§  Explanation

Records generate equals/hashCode from all components. Rule "identity by default" breaksâ€”records use value semantics.

---

## ğŸ¯ DSA 12 â€” Rule break: Arrays.equals vs Arrays.deepEquals

```java
int[][] a = {{1}, {2}};
int[][] b = {{1}, {2}};
System.out.println(Arrays.equals(a, b));
System.out.println(Arrays.deepEquals(a, b));
```

### âœ… Answer

```
false
true
```

### ğŸ§  Explanation

Arrays.equals compares references of inner arrays; deepEquals compares contents. Rule "equals compares logically" breaks for nested arrays.

---

## ğŸŒŸ Why this topic is **non-negotiable**

* Causes **ghost bugs** in HashMap / HashSet
* Breaks caching layers
* Interviewers use this to judge **production maturity**

---

### â–¶ï¸ Next step

Reply with **`5`** to continue:

## ğŸ”¥ **Strings & String Pool (Memory + Performance Traps)**

Same colorful `.md`, same strict DSA interview format.
