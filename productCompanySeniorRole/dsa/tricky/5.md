Locked âœ…
Proceeding with **Topic 5** in the same **colorful `.md`**, **strict DSA**, **interview-ready** format.

---

## ðŸ“„ **File name:** `java-strings-dsa.md`

# ðŸ§  **DSA Questions â€“ Strings & String Pool (Java)**

*(Senior Backend | Barclays / Enterprise Java)*

---

## ðŸŽ¯ DSA 1 â€” Literal vs Heap Object

```java
String a = "java";
String b = new String("java");
System.out.println(a == b);
```

**Answer:**

```
false
```

**Explanation:**
String literals are interned in the **String Pool**; `new` creates a separate heap object.

---

## ðŸŽ¯ DSA 2 â€” Pool Reuse

```java
String a = "backend";
String b = "backend";
System.out.println(a == b);
```

**Answer:**

```
true
```

**Explanation:**
Both references point to the same pooled literal.

---

## ðŸŽ¯ DSA 3 â€” `intern()` Effect

```java
String a = new String("jvm");
String b = a.intern();
System.out.println(a == b);
```

**Answer:**

```
false
```

**Explanation:**
`intern()` returns the pooled reference, not the heap instance.

---

## ðŸŽ¯ DSA 4 â€” Compile-time Concatenation

```java
String a = "java" + "backend";
String b = "javabackend";
System.out.println(a == b);
```

**Answer:**

```
true
```

**Explanation:**
Compile-time constants are folded and interned.

---

## ðŸŽ¯ DSA 5 â€” Runtime Concatenation

```java
String x = "java";
String a = x + "backend";
String b = "javabackend";
System.out.println(a == b);
```

**Answer:**

```
false
```

**Explanation:**
Runtime concatenation creates a new heap String.

---

## ðŸŽ¯ DSA 6 â€” `equals()` vs `==`

```java
String a = new String("api");
String b = new String("api");
System.out.println(a == b);
System.out.println(a.equals(b));
```

**Answer:**

```
false
true
```

**Explanation:**
`==` compares references; `equals()` compares content.

---

## ðŸŽ¯ DSA 7 â€” Immutability Trap

```java
String s = "java";
s.concat(" backend");
System.out.println(s);
```

**Answer:**

```
java
```

**Explanation:**
Strings are immutable; the result is discarded.

---

## ðŸŽ¯ DSA 8 â€” Reassignment Required

```java
String s = "java";
s = s.concat(" backend");
System.out.println(s);
```

**Answer:**

```
java backend
```

**Explanation:**
You must assign the new String to keep the change.

---

## ðŸŽ¯ DSA 9 â€” `StringBuilder` Mutation

```java
StringBuilder sb = new StringBuilder("java");
sb.append(" backend");
System.out.println(sb.toString());
```

**Answer:**

```
java backend
```

**Explanation:**
`StringBuilder` is mutable; changes affect the same object.

---

## ðŸŽ¯ DSA 10 â€” `StringBuffer` vs `StringBuilder`

```java
StringBuffer sb = new StringBuffer("api");
sb.append(" service");
System.out.println(sb.toString());
```

**Answer:**

```
api service
```

**Explanation:**
`StringBuffer` is synchronized (thread-safe) but slower.

---

## ðŸŽ¯ DSA 11 â€” Loop Concatenation Pitfall

```java
String s = "";
for(int i = 0; i < 3; i++) {
    s += i;
}
System.out.println(s);
```

**Answer:**

```
012
```

**Explanation:**
Each `+=` creates a new String â†’ **allocation overhead**.

---

## ðŸŽ¯ DSA 12 â€” Better Loop Concatenation

```java
StringBuilder sb = new StringBuilder();
for(int i = 0; i < 3; i++) {
    sb.append(i);
}
System.out.println(sb.toString());
```

**Answer:**

```
012
```

**Explanation:**
Single mutable buffer â†’ fewer allocations, better performance.

---

## ðŸŒŸ Why this topic matters

* Prevents **memory bloat**
* Improves **throughput**
* Avoids **hidden performance regressions**
* Interviewers expect mastery here

---

### â–¶ï¸ Next step

Reply with **`6`** to continue:

## ðŸ”¥ **Collections Framework â€“ Fundamentals**

Same colorful `.md`, same strict DSA interview format.
