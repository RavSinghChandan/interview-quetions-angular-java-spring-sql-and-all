Locked âœ…
Proceeding with **Topic 6** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-collections-dsa.md`

# ğŸ§  **DSA Questions â€“ Collections Framework Fundamentals (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

---

## ğŸ¯ DSA 1 â€” Rule break: `Arrays.asList` returns fixed-size list

```java
List<Integer> list = Arrays.asList(1, 2, 3);
list.add(4);
```

**Answer:**

```
UnsupportedOperationException
```

**Explanation:**
Returned list is backed by array; add/remove unsupported. Rule "List supports add" breaks for asList.

---

## ğŸ¯ DSA 2 â€” Rule break: `Arrays.asList` on primitive array

```java
int[] arr = {1, 2, 3};
List<int[]> list = Arrays.asList(arr);
System.out.println(list.size());
```

**Answer:**

```
1
```

**Explanation:**
Primitive array becomes single element (int[]). Rule "asList creates list of elements" breaks for primitives.

---

## ğŸ¯ DSA 3 â€” Rule break: `Collections.unmodifiableList` wraps reference

```java
List<Integer> inner = new ArrayList<>();
inner.add(1);
List<Integer> unmod = Collections.unmodifiableList(inner);
inner.add(2);
System.out.println(unmod.size());
```

**Answer:**

```
2
```

**Explanation:**
UnmodifiableList is a view; mutating underlying list changes it. Rule "unmodifiable = immutable" breaks.

---

## ğŸ¯ DSA 4 â€” Rule break: `TreeSet` / `TreeMap` with nullâ€”NullPointerException

```java
Set<String> set = new TreeSet<>();
set.add(null);
```

**Answer:**

```
NullPointerException
```

**Explanation:**
TreeSet uses Comparable; null has no natural order. Rule "Set allows null" breaks for TreeSet.

---

## ğŸ¯ DSA 5 â€” Rule break: `Hashtable` vs `HashMap`â€”null keys/values

```java
Map<String, String> map = new Hashtable<>();
map.put(null, "value");
```

**Answer:**

```
NullPointerException
```

**Explanation:**
Hashtable disallows null keys and values. Rule "Map allows null value" breaks for Hashtable.

---

## ğŸ¯ DSA 6 â€” Rule break: `ConcurrentHashMap`â€”null not allowed

```java
Map<String, String> map = new ConcurrentHashMap<>();
map.put("key", null);
```

**Answer:**

```
NullPointerException
```

**Explanation:**
CHM disallows null to avoid ambiguity (containsKey vs get). Rule "Map allows null value" breaks for CHM.

---

## ğŸ¯ DSA 7 â€” Rule break: Fail-fast iteratorâ€”structural modification

```java
List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
for(Integer i : list) {
    list.add(3);
}
```

**Answer:**

```
ConcurrentModificationException
```

**Explanation:**
Structural change during iteration triggers fail-fast. Rule "foreach is safe" breaks when mutating.

---

## ğŸ¯ DSA 8 â€” Rule break: `remove` in for-loopâ€”wrong index

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 2, 3));
for(int i = 0; i < list.size(); i++) {
    if(list.get(i) == 2) list.remove(i);
}
System.out.println(list);
```

**Answer:**

```
[1, 2, 3]
```

**Explanation:**
Removing shifts indices; second 2 is skipped. Rule "loop removes all matches" breaks without adjusting index.

---

## ğŸ¯ DSA 9 â€” Rule break: `LinkedList.get(i)` is O(n)

```java
List<String> list = new LinkedList<>();
for(int i = 0; i < 1000; i++) list.add("x");
list.get(999);  // Traverses 999 nodes
```

**Answer:**

```
O(n) per get
```

**Explanation:**
LinkedList has no random access; each get traverses. Rule "List get is O(1)" breaks for LinkedList.

---

## ğŸ¯ DSA 10 â€” Rule break: `subList` is viewâ€”backing list mutation

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
List<Integer> sub = list.subList(0, 2);
list.add(4);
sub.get(0);  // May throw
```

**Answer:**

```
ConcurrentModificationException (or undefined)
```

**Explanation:**
subList is backed by original; structural change to backing invalidates subList. Rule "subList is independent" breaks.

---

## ğŸ¯ DSA 11 â€” Rule break: `Collections.sort` mutates list

```java
List<Integer> list = Arrays.asList(1, 3, 2);
Collections.sort(list);
```

**Answer:**

```
Modifies list in place; asList returns fixed-size
```

**Explanation:**
sort mutates; Arrays.asList allows set but not add/remove. sort works here but rule "sort returns new" breaksâ€”it mutates.

---

## ğŸ¯ DSA 12 â€” Rule break: `remove(Object)` vs `remove(int)`

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
list.remove(1);      // Removes index 1 â†’ [1, 3]
list.remove(Integer.valueOf(1));  // Removes element 1 â†’ [3]
```

**Answer:**

```
First: [1, 3], Second: [3]
```

**Explanation:**
remove(int) removes by index; remove(Object) removes by equals. Rule "remove removes element" is ambiguousâ€”overload breaks.

---

## ğŸ¯ DSA 13 â€” Rule break: `Iterator.remove` without `next`

```java
Iterator<Integer> it = list.iterator();
it.remove();  // IllegalStateException
```

**Answer:**

```
IllegalStateException
```

**Explanation:**
remove() must follow next(). Rule "iterator supports remove" breaks if next() not called first.

---

## ğŸ¯ DSA 14 â€” Rule break: `CopyOnWriteArrayList` iterates snapshot

```java
List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(1, 2));
for(Integer i : list) {
    list.add(3);
}
System.out.println(list);
```

**Answer:**

```
[1, 2, 3, 3]
```

**Explanation:**
Iterator uses snapshot; add doesn't affect current iteration. Rule "iteration sees all changes" breaks for COW collections.

---

## ğŸ¯ DSA 15 â€” Rule break: `PriorityQueue` iteration order

```java
Queue<Integer> pq = new PriorityQueue<>(Arrays.asList(3, 1, 2));
System.out.println(pq);
```

**Answer:**

```
[1, 2, 3] or [1, 3, 2]â€”heap order, not sorted
```

**Explanation:**
PriorityQueue iteration is not sorted; only poll() returns in order. Rule "iteration = sorted" breaks.

---

## ğŸŒŸ Why this topic matters

* Direct impact on **performance**
* Prevents **runtime exceptions**
* Interviewers expect **daily-use mastery**
* Wrong choice â†’ scalability issues

---

### â–¶ï¸ Next step

Reply with **`7`** to continue:

## ğŸ”¥ **HashMap Internals (High-Value Senior Topic)**
