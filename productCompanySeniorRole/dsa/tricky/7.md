Locked âœ…
Proceeding with **Topic 7** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-hashmap-dsa.md`

# ğŸ§  **DSA Questions â€“ HashMap Internals (Java)**

*(Senior Backend | Barclays / Enterprise Java)*

> ğŸ”¥ This topic **separates seniors from everyone else**.
> Focus: hashing, collisions, resizing, and Java 8+ behavior.

---

## ğŸ¯ DSA 1 â€” Basic put/get

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
System.out.println(map.get("A"));
```

**Answer:**

```
1
```

**Explanation:**
Value is retrieved using `hashCode()` â†’ bucket â†’ `equals()`.

---

## ğŸ¯ DSA 2 â€” Overwriting existing key

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("A", 2);
System.out.println(map.size());
```

**Answer:**

```
1
```

**Explanation:**
Same key replaces the value; size does not increase.

---

## ğŸ¯ DSA 3 â€” `equals()` true, `hashCode()` different

```java
class Key {
    int id;
    Key(int id) { this.id = id; }
    public boolean equals(Object o) {
        return ((Key)o).id == id;
    }
}

Map<Key, String> map = new HashMap<>();
map.put(new Key(1), "X");
System.out.println(map.get(new Key(1)));
```

**Answer:**

```
null
```

**Explanation:**
Without overriding `hashCode()`, equal keys land in different buckets.

---

## ğŸ¯ DSA 4 â€” Same `hashCode()`, different objects

```java
class Key {
    public int hashCode() { return 1; }
}

Map<Key, String> map = new HashMap<>();
map.put(new Key(), "A");
map.put(new Key(), "B");
System.out.println(map.size());
```

**Answer:**

```
2
```

**Explanation:**
Hash collision handled via chaining / tree nodes.

---

## ğŸ¯ DSA 5 â€” Collision performance impact

```java
class Key {
    public int hashCode() { return 1; }
}

Map<Key, Integer> map = new HashMap<>();
```

**Answer:**

```
Lookup degrades to O(n)
```

**Explanation:**
All keys land in the same bucket.

---

## ğŸ¯ DSA 6 â€” Null key behavior

```java
Map<String, String> map = new HashMap<>();
map.put(null, "A");
map.put(null, "B");
System.out.println(map.size());
```

**Answer:**

```
1
```

**Explanation:**
`HashMap` allows **one null key**, value gets overwritten.

---

## ğŸ¯ DSA 7 â€” Null value behavior

```java
Map<String, String> map = new HashMap<>();
map.put("A", null);
map.put("B", null);
System.out.println(map.size());
```

**Answer:**

```
2
```

**Explanation:**
Multiple null values are allowed.

---

## ğŸ¯ DSA 8 â€” Initial capacity & resizing

```java
Map<Integer, Integer> map = new HashMap<>(16);
for(int i = 0; i < 13; i++) {
    map.put(i, i);
}
```

**Answer:**

```
No resize yet
```

**Explanation:**
Resize happens when size > capacity Ã— load factor (16 Ã— 0.75 = 12).

---

## ğŸ¯ DSA 9 â€” Resize trigger

```java
Map<Integer, Integer> map = new HashMap<>(16);
for(int i = 0; i < 13; i++) {
    map.put(i, i);
}
map.put(13, 13);
```

**Answer:**

```
Resize occurs
```

**Explanation:**
Threshold exceeded â†’ capacity doubles.

---

## ğŸ¯ DSA 10 â€” Load factor effect

```java
Map<Integer, Integer> map = new HashMap<>(16, 1.0f);
```

**Answer:**

```
Fewer resizes, more collisions
```

**Explanation:**
Higher load factor trades memory for collision risk.

---

## ğŸ¯ DSA 11 â€” Java 8 treeification trigger

```java
Map<Key, Integer> map = new HashMap<>();
```

**Answer:**

```
Bucket converts to Red-Black Tree after many collisions
```

**Explanation:**
When bucket size > 8 and capacity â‰¥ 64, linked list â†’ tree.

---

## ğŸ¯ DSA 12 â€” Treeification benefit

```java
Map<Key, Integer> map = new HashMap<>();
```

**Answer:**

```
Lookup improves to O(log n)
```

**Explanation:**
Tree nodes replace linked list for heavy collisions.

---

## ğŸ¯ DSA 13 â€” Bad `hashCode()` smell

```java
class Key {
    public int hashCode() { return 42; }
}
```

**Answer:**

```
Severe performance degradation
```

**Explanation:**
All keys collide into one bucket.

---

## ğŸ¯ DSA 14 â€” Good `hashCode()` principle

```java
class Key {
    int id;
    public int hashCode() {
        return Integer.hashCode(id);
    }
}
```

**Answer:**

```
Uniform key distribution
```

**Explanation:**
Good hashing spreads keys evenly across buckets.

---

## ğŸ¯ DSA 15 â€” `containsKey` vs `get`

```java
Map<String, String> map = new HashMap<>();
map.put("A", null);
System.out.println(map.containsKey("A"));
System.out.println(map.get("A"));
```

**Answer:**

```
true
null
```

**Explanation:**
`containsKey` checks key presence, `get` returns value.

---

## ğŸŒŸ Why this topic is critical

* Prevents **hidden O(n) bugs**
* Essential for **caching, maps, deduplication**
* Interviewers expect internal understanding, not just usage

---

### â–¶ï¸ Next step

Reply with **`8`** to continue:

## ğŸ”¥ **Concurrency Fundamentals (Threads, Visibility, `volatile`)**

Same colorful `.md`, same strict DSA interview format.
