Locked âœ…
Proceeding with **Topic 7** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-hashmap-dsa.md`

# ğŸ§  **DSA Questions â€“ HashMap Internals (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> ğŸ”¥ This topic **separates seniors from everyone else**.
> Focus: hashing, collisions, resizing, and Java 8+ behavior.

---

## ğŸ¯ DSA 1 â€” Rule break: `get` returns nullâ€”key absent or value null?

```java
Map<String, String> map = new HashMap<>();
map.put("A", null);
System.out.println(map.containsKey("A"));
System.out.println(map.get("A"));
```

**Answer:**

```
true
null
```

**Explanation:**
get(null) and get(missing) both return null. Rule "null means absent" breaks when value can be null.

---

## ğŸ¯ DSA 2 â€” Rule break: Mutable keyâ€”hash changes after put

```java
Map<Key, String> map = new HashMap<>();
Key k = new Key(1);
map.put(k, "X");
k.id = 2;
System.out.println(map.get(k));
System.out.println(map.get(new Key(1)));
```

**Answer:**

```
null
null
```

**Explanation:**
Key hash changed; both lookups go to wrong bucket. Rule "key identifies entry" breaks when key mutates.

---

## ğŸ¯ DSA 3 â€” Rule break: HashMap allows one null key

```java
Map<String, String> map = new HashMap<>();
map.put(null, "A");
map.put(null, "B");
System.out.println(map.size());
System.out.println(map.get(null));
```

**Answer:**

```
1
B
```

**Explanation:**
Single null key; second put overwrites. Rule "unique keys" holds but null key is special.

---

## ğŸ¯ DSA 4 â€” Rule break: TreeMap null keyâ€”NPE

```java
Map<String, String> map = new TreeMap<>();
map.put(null, "X");
```

**Answer:**

```
NullPointerException
```

**Explanation:**
TreeMap uses Comparable; null has no order. Rule "Map allows null key" breaks for TreeMap.

---

## ğŸ¯ DSA 5 â€” Rule break: Bad hashCodeâ€”O(n) lookup

```java
class Key { public int hashCode() { return 1; } }
Map<Key, Integer> map = new HashMap<>();
for(int i = 0; i < 1000; i++) map.put(new Key(), i);
map.get(new Key());  // O(n) traversal
```

**Answer:**

```
Degrades to O(n)
```

**Explanation:**
All keys collide; single bucket becomes linked list (or tree). Rule "HashMap get is O(1)" breaks.

---

## ğŸ¯ DSA 6 â€” Rule break: Load factor 0â€”infinite resize

```java
Map<Integer, Integer> map = new HashMap<>(16, 0.0f);
```

**Answer:**

```
Resize on every put
```

**Explanation:**
Load factor 0 means threshold 0; resize every put. Rule "load factor controls resize" breaks at 0.

---

## ğŸ¯ DSA 7 â€” Rule break: Capacity rounds to power of 2

```java
Map<Integer, Integer> map = new HashMap<>(10);
// Actual capacity = 16
```

**Answer:**

```
Capacity 16
```

**Explanation:**
HashMap rounds capacity to next power of 2. Rule "capacity = constructor arg" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: Treeification thresholdâ€”8 nodes, 64 capacity

```java
// Bucket converts to tree only when: size > 8 AND capacity >= 64
// Before that, linked list
```

**Answer:**

```
Treeification conditional
```

**Explanation:**
Small tables keep linked list; tree only when capacity â‰¥ 64 and bucket > 8. Rule "collision = tree" breaks for small maps.

---

## ğŸ¯ DSA 9 â€” Rule break: `computeIfAbsent` recursion

```java
Map<String, Integer> map = new HashMap<>();
map.computeIfAbsent("a", k -> {
    map.put("b", 1);  // Modifying during computation
    return 2;
});
```

**Answer:**

```
IllegalStateException or undefined
```

**Explanation:**
Modifying map during computeIfAbsent can cause CME or recursion. Rule "compute is atomic" breaks with reentrant modification.

---

## ğŸ¯ DSA 10 â€” Rule break: `merge` null valueâ€”removes entry

```java
Map<String, String> map = new HashMap<>();
map.put("A", "X");
map.merge("A", "Y", (o, n) -> null);
System.out.println(map.containsKey("A"));
```

**Answer:**

```
false
```

**Explanation:**
merge remapping returns null â†’ entry removed. Rule "merge updates value" breaks when remapper returns null.

---

## ğŸ¯ DSA 11 â€” Rule break: `keySet().remove` affects map

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.keySet().remove("A");
System.out.println(map.size());
```

**Answer:**

```
0
```

**Explanation:**
keySet is a view; remove removes from backing map. Rule "keySet is snapshot" breaks.

---

## ğŸ¯ DSA 12 â€” Rule break: `entrySet().iterator().remove` during iteration

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
Iterator<Map.Entry<String, Integer>> it = map.entrySet().iterator();
it.next();
it.remove();
System.out.println(map.size());
```

**Answer:**

```
1
```

**Explanation:**
Iterator.remove removes from map. Rule "iterator doesn't modify" breaksâ€”it does when using remove().

---

## ğŸ¯ DSA 13 â€” Rule break: IdentityHashMapâ€”reference equality

```java
Map<String, Integer> map = new IdentityHashMap<>();
map.put("a", 1);
map.put("a", 2);  // Different object if interned
map.put(new String("a"), 3);
```

**Answer:**

```
Size 2 or 3 depending on literal reuse
```

**Explanation:**
IdentityHashMap uses == for keys. Rule "Map uses equals" breaksâ€”uses identity.

---

## ğŸ¯ DSA 14 â€” Rule break: EnumMapâ€”null key NPE

```java
enum E { A, B }
Map<E, String> map = new EnumMap<>(E.class);
map.put(null, "X");
```

**Answer:**

```
NullPointerException
```

**Explanation:**
EnumMap disallows null key. Rule "Map allows null key" breaks for EnumMap.

---

## ğŸ¯ DSA 15 â€” Rule break: `ConcurrentHashMap`â€”no size() accuracy during writes

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
// size() can be approximate during concurrent modifications
```

**Answer:**

```
Approximate during concurrency
```

**Explanation:**
CHM size() is not always exact during concurrent updates. Rule "size is exact" breaks for CHM.

---

## ğŸŒŸ Why this topic is critical

* Prevents **hidden O(n) bugs**
* Essential for **caching, maps, deduplication**
* Interviewers expect internal understanding, not just usage

---

### â–¶ï¸ Next step

Reply with **`8`** to continue:

## ğŸ”¥ **Concurrency Fundamentals (Threads, Visibility, `volatile`)**

Same colorful `.md`, same strict DSA interview format.
