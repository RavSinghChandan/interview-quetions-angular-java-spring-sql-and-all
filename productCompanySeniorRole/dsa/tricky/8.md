Locked âœ…
Proceeding with **Topic 8** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-concurrency-dsa.md`

# ğŸ§  **DSA Questions â€“ Concurrency Fundamentals (Java)**

*(Senior Backend | Barclays / Enterprise Java)*

> âš ï¸ This topic exposes **race conditions, visibility bugs, and false confidence**.
> Strong seniors reason about **what can happen**, not what â€œusually happensâ€.

---

## ğŸ¯ DSA 1 â€” Race Condition (no synchronization)

```java
int count = 0;

new Thread(() -> count++).start();
new Thread(() -> count++).start();

Thread.sleep(100);
System.out.println(count);
```

**Answer:**

```
0, 1, or 2
```

**Explanation:**
`count++` is **not atomic**; race conditions lead to lost updates.

---

## ğŸ¯ DSA 2 â€” Atomicity vs Visibility

```java
volatile int x = 0;

new Thread(() -> x++).start();
new Thread(() -> x++).start();

Thread.sleep(100);
System.out.println(x);
```

**Answer:**

```
0, 1, or 2
```

**Explanation:**
`volatile` ensures **visibility**, not **atomicity**.

---

## ğŸ¯ DSA 3 â€” Visibility guarantee with `volatile`

```java
volatile boolean running = true;

new Thread(() -> {
    while (running) {}
}).start();

Thread.sleep(100);
running = false;
```

**Answer:**

```
Loop eventually terminates
```

**Explanation:**
`volatile` guarantees visibility of updates across threads.

---

## ğŸ¯ DSA 4 â€” Without `volatile` (classic bug)

```java
boolean running = true;

new Thread(() -> {
    while (running) {}
}).start();

Thread.sleep(100);
running = false;
```

**Answer:**

```
Loop may never terminate
```

**Explanation:**
Thread may cache `running` value; no visibility guarantee.

---

## ğŸ¯ DSA 5 â€” `synchronized` ensures atomicity

```java
int count = 0;

synchronized void inc() {
    count++;
}

new Thread(this::inc).start();
new Thread(this::inc).start();
```

**Answer:**

```
count becomes 2
```

**Explanation:**
`synchronized` ensures **mutual exclusion + visibility**.

---

## ğŸ¯ DSA 6 â€” Synchronization on different objects

```java
Object a = new Object();
Object b = new Object();

synchronized(a) { /* T1 */ }
synchronized(b) { /* T2 */ }
```

**Answer:**

```
Both blocks can run concurrently
```

**Explanation:**
Locks are **object-specific**, not global.

---

## ğŸ¯ DSA 7 â€” `volatile` is NOT a lock

```java
volatile int count = 0;

count++;
```

**Answer:**

```
Not thread-safe
```

**Explanation:**
Read-modify-write is still non-atomic.

---

## ğŸ¯ DSA 8 â€” Happens-before via `synchronized`

```java
synchronized void write() {
    x = 10;
}

synchronized void read() {
    System.out.println(x);
}
```

**Answer:**

```
read() sees latest value of x
```

**Explanation:**
Lock release â†’ lock acquire establishes **happens-before**.

---

## ğŸ¯ DSA 9 â€” Happens-before via `volatile`

```java
volatile int x;

x = 10;
System.out.println(x);
```

**Answer:**

```
Always prints 10
```

**Explanation:**
Write to volatile happens-before subsequent reads.

---

## ğŸ¯ DSA 10 â€” Instruction reordering risk

```java
int a = 0;
boolean flag = false;

Thread t1: a = 1; flag = true;
Thread t2: if(flag) System.out.println(a);
```

**Answer:**

```
May print 0
```

**Explanation:**
Without synchronization, writes may be reordered.

---

## ğŸ¯ DSA 11 â€” Fixing reordering with `volatile`

```java
int a = 0;
volatile boolean flag = false;
```

**Answer:**

```
Always prints 1
```

**Explanation:**
`volatile` prevents reordering around it.

---

## ğŸ¯ DSA 12 â€” Deadlock scenario

```java
synchronized(a) {
    synchronized(b) { }
}

synchronized(b) {
    synchronized(a) { }
}
```

**Answer:**

```
Possible deadlock
```

**Explanation:**
Circular lock acquisition order.

---

## ğŸ¯ DSA 13 â€” Avoiding deadlock

```java
synchronized(a) {
    synchronized(b) { }
}
```

**Answer:**

```
No deadlock (consistent order)
```

**Explanation:**
Always lock objects in the same order.

---

## ğŸ¯ DSA 14 â€” Thread start happens-before

```java
x = 10;
new Thread(() -> System.out.println(x)).start();
```

**Answer:**

```
Always prints 10
```

**Explanation:**
Thread start establishes **happens-before**.

---

## ğŸ¯ DSA 15 â€” Thread join happens-before

```java
Thread t = new Thread(() -> x = 10);
t.start();
t.join();
System.out.println(x);
```

**Answer:**

```
Always prints 10
```

**Explanation:**
`join()` guarantees visibility of thread completion.

---

## ğŸŒŸ Why this topic is critical

* Prevents **data races**
* Avoids **heisenbugs**
* Required for **high-throughput backend systems**
* Interviewers expect reasoning, not guessing

---

### â–¶ï¸ Next step

Reply with **`9`** to continue:

## ğŸ”¥ **Concurrent Collections & Utilities (Real-world Backend Usage)**
