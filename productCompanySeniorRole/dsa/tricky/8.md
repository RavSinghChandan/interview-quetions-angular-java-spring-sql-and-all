Locked âœ…
Proceeding with **Topic 8** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-concurrency-dsa.md`

# ğŸ§  **DSA Questions â€“ Concurrency Fundamentals (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ This topic exposes **race conditions, visibility bugs, and false confidence**.
> Strong seniors reason about **what can happen**, not what "usually happens".

---

## ğŸ¯ DSA 1 â€” Rule break: `volatile` guarantees visibility, NOT atomicity

```java
volatile int x = 0;
new Thread(() -> { for(int i=0; i<1000; i++) x++; }).start();
new Thread(() -> { for(int i=0; i<1000; i++) x++; }).start();
Thread.sleep(500);
System.out.println(x);  // May be < 2000
```

**Answer:**

```
Less than 2000 possible
```

**Explanation:**
volatile ensures visibility, not atomicity. x++ is read-modify-write; races still lose updates. Rule "volatile = thread-safe" breaks.

---

## ğŸ¯ DSA 2 â€” Rule break: Double-checked locking without volatile

```java
class Singleton {
    private static Singleton instance;
    static Singleton get() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) instance = new Singleton();
            }
        }
        return instance;
    }
}
```

**Answer:**

```
Half-initialized object possible
```

**Explanation:**
Without volatile on instance, another thread can see non-null but not-fully-constructed object. Rule "synchronized is enough" breaks for DCL.

---

## ğŸ¯ DSA 3 â€” Rule break: Reorderingâ€”happens-before not guaranteed

```java
int a = 0, b = 0;
// Thread 1: a = 1; b = 1;
// Thread 2: if (b == 1) System.out.println(a);
// May print 0
```

**Answer:**

```
Can print 0
```

**Explanation:**
Compiler/JVM may reorder; without synchronization, Thread 2 can see b=1 but a=0. Rule "sequential consistency" breaks.

---

## ğŸ¯ DSA 4 â€” Rule break: `synchronized` on different objectsâ€”no mutual exclusion

```java
Object lock1 = new Object();
Object lock2 = new Object();
// Thread 1: synchronized(lock1) { ... }
// Thread 2: synchronized(lock2) { ... }
// No mutual exclusion
```

**Answer:**

```
Both can run concurrently
```

**Explanation:**
Different locks = different critical sections. Rule "synchronized = one at a time" breaks when locks differ.

---

## ğŸ¯ DSA 5 â€” Rule break: `wait` without owning lockâ€”IllegalMonitorStateException

```java
Object lock = new Object();
lock.wait();  // Not in synchronized(lock) block
```

**Answer:**

```
IllegalMonitorStateException
```

**Explanation:**
wait() must be called while holding the lock. Rule "wait pauses thread" breaks without lock ownership.

---

## ğŸ¯ DSA 6 â€” Rule break: Spurious wakeupâ€”`while` not `if`

```java
synchronized (lock) {
    if (!condition) lock.wait();  // WRONG
    // condition may still be false after wakeup
}
```

**Answer:**

```
Use while (!condition) lock.wait();
```

**Explanation:**
Spurious wakeups can occur; condition must be rechecked. Rule "notify wakes when condition true" breaks.

---

## ğŸ¯ DSA 7 â€” Rule break: `Thread.sleep` does NOT release lock

```java
synchronized (lock) {
    Thread.sleep(1000);  // Holds lock; others block
}
```

**Answer:**

```
Lock held during sleep
```

**Explanation:**
sleep() does not release monitor. Rule "sleep pauses" holds, but "paused = lock released" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: `interrupt` on sleeping threadâ€”InterruptedException

```java
Thread t = new Thread(() -> {
    try { Thread.sleep(10000); } catch (InterruptedException e) { }
});
t.start();
t.interrupt();
```

**Answer:**

```
InterruptedException thrown, sleep exits
```

**Explanation:**
interrupt() wakes sleeping thread and throws. Rule "sleep runs to completion" breaks when interrupted.

---

## ğŸ¯ DSA 9 â€” Rule break: Daemon threadsâ€”JVM exits without them finishing

```java
Thread t = new Thread(() -> { while(true) {} });
t.setDaemon(true);
t.start();
// main exits â†’ JVM exits â†’ daemon killed
```

**Answer:**

```
Daemon thread terminated abruptly
```

**Explanation:**
Daemon threads don't keep JVM alive. Rule "all threads complete" breaks for daemons.

---

## ğŸ¯ DSA 10 â€” Rule break: `ThreadLocal` in thread poolâ€”leak

```java
ExecutorService exec = Executors.newFixedThreadPool(10);
exec.submit(() -> {
    ThreadLocal<byte[]> tl = new ThreadLocal<>();
    tl.set(new byte[1024*1024]);
    // Never remove; thread reused; leak
});
```

**Answer:**

```
Memory leak
```

**Explanation:**
Pooled threads reused; ThreadLocal not cleared leaks. Rule "ThreadLocal is per-thread" breaks in pools.

---

## ğŸ¯ DSA 11 â€” Rule break: `start()` twiceâ€”IllegalThreadStateException

```java
Thread t = new Thread(() -> {});
t.start();
t.start();
```

**Answer:**

```
IllegalThreadStateException
```

**Explanation:**
Thread can only be started once. Rule "start begins execution" breaks on second start.

---

## ğŸ¯ DSA 12 â€” Rule break: `join()` without `start()`â€”no effect

```java
Thread t = new Thread(() -> {});
t.join();  // Returns immediately; run never executed
```

**Answer:**

```
join returns immediately
```

**Explanation:**
join() on non-started thread returns immediately. Rule "join waits for completion" breaks when never started.

---

## ğŸŒŸ Why this topic matters

* Backend services are **multi-threaded**
* Visibility and atomicity bugs are **subtle**
* Interviewers expect **JMM awareness**

---

### â–¶ï¸ Next step

Reply with **`9`** to continue:

## ğŸ”¥ **Concurrent Collections & Utilities**

Same colorful `.md`, same strict DSA interview format.
