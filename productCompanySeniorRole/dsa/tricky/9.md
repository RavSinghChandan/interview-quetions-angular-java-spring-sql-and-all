Locked âœ…
Proceeding with **Topic 9** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-concurrent-collections-dsa.md`

# ğŸ§  **DSA Questions â€“ Concurrent Collections & Utilities (Java)**

*(Senior Backend | Barclays / Enterprise Java)*

> âš ï¸ Focus: **thread safety, performance trade-offs, and real production behavior**.

---

## ğŸ¯ DSA 1 â€” `ConcurrentHashMap` vs `HashMap`

```java
Map<Integer, String> map = new ConcurrentHashMap<>();
map.put(1, "A");
map.put(2, "B");
System.out.println(map.size());
```

**Answer:**

```
2
```

**Explanation:**
`ConcurrentHashMap` supports concurrent access without global locking.

---

## ğŸ¯ DSA 2 â€” Null key restriction

```java
Map<String, String> map = new ConcurrentHashMap<>();
map.put(null, "A");
```

**Answer:**

```
NullPointerException
```

**Explanation:**
`ConcurrentHashMap` does **not allow null keys or values**.

---

## ğŸ¯ DSA 3 â€” Concurrent modification (safe)

```java
Map<Integer, Integer> map = new ConcurrentHashMap<>();
map.put(1, 1);
for(Integer k : map.keySet()) {
    map.put(2, 2);
}
System.out.println(map.size());
```

**Answer:**

```
2
```

**Explanation:**
Iterators are **weakly consistent**, not fail-fast.

---

## ğŸ¯ DSA 4 â€” HashMap vs ConcurrentHashMap iteration

```java
Map<Integer, Integer> map = new HashMap<>();
map.put(1, 1);
for(Integer k : map.keySet()) {
    map.put(2, 2);
}
```

**Answer:**

```
ConcurrentModificationException
```

**Explanation:**
`HashMap` iterators are **fail-fast**.

---

## ğŸ¯ DSA 5 â€” Atomic increment

```java
AtomicInteger x = new AtomicInteger(0);
x.incrementAndGet();
System.out.println(x.get());
```

**Answer:**

```
1
```

**Explanation:**
Atomic classes use **CAS (compare-and-swap)** for lock-free updates.

---

## ğŸ¯ DSA 6 â€” Atomic vs volatile

```java
volatile int x = 0;
x++;
```

**Answer:**

```
Not thread-safe
```

**Explanation:**
`volatile` gives visibility, not atomicity.

---

## ğŸ¯ DSA 7 â€” LongAdder advantage

```java
LongAdder adder = new LongAdder();
adder.increment();
System.out.println(adder.sum());
```

**Answer:**

```
1
```

**Explanation:**
`LongAdder` reduces contention under high concurrency.

---

## ğŸ¯ DSA 8 â€” `CopyOnWriteArrayList` behavior

```java
List<Integer> list = new CopyOnWriteArrayList<>();
list.add(1);
for(Integer i : list) {
    list.add(2);
}
System.out.println(list);
```

**Answer:**

```
[1, 2]
```

**Explanation:**
Iteration happens on a **snapshot copy**.

---

## ğŸ¯ DSA 9 â€” Memory cost of Copy-on-Write

```java
List<Integer> list = new CopyOnWriteArrayList<>();
```

**Answer:**

```
High memory overhead on writes
```

**Explanation:**
Each write creates a new internal array.

---

## ğŸ¯ DSA 10 â€” BlockingQueue behavior

```java
BlockingQueue<Integer> q = new ArrayBlockingQueue<>(1);
q.put(1);
q.put(2);
```

**Answer:**

```
Second put blocks
```

**Explanation:**
Queue is full; `put()` waits for space.

---

## ğŸ¯ DSA 11 â€” Non-blocking offer

```java
BlockingQueue<Integer> q = new ArrayBlockingQueue<>(1);
q.offer(1);
System.out.println(q.offer(2));
```

**Answer:**

```
false
```

**Explanation:**
`offer()` returns immediately if full.

---

## ğŸ¯ DSA 12 â€” Executor basic usage

```java
ExecutorService ex = Executors.newFixedThreadPool(2);
ex.submit(() -> System.out.println("task"));
```

**Answer:**

```
Task executed by a pooled thread
```

**Explanation:**
Thread pools reuse threads to reduce creation cost.

---

## ğŸ¯ DSA 13 â€” Executor shutdown trap

```java
ExecutorService ex = Executors.newSingleThreadExecutor();
ex.submit(() -> {});
System.out.println(ex.isShutdown());
```

**Answer:**

```
false
```

**Explanation:**
Executor keeps running until explicitly shut down.

---

## ğŸ¯ DSA 14 â€” Proper shutdown

```java
ExecutorService ex = Executors.newSingleThreadExecutor();
ex.shutdown();
```

**Answer:**

```
No new tasks accepted
```

**Explanation:**
Existing tasks complete before termination.

---

## ğŸ¯ DSA 15 â€” Callable vs Runnable

```java
Future<Integer> f = ex.submit(() -> 10);
System.out.println(f.get());
```

**Answer:**

```
10
```

**Explanation:**
`Callable` can return results and throw checked exceptions.

---

## ğŸŒŸ Why this topic matters

* Prevents **race conditions**
* Improves **throughput**
* Avoids **thread starvation**
* Essential for **real backend systems**

---

### â–¶ï¸ Next step

Reply with **`10`** to continue:

## ğŸ”¥ **Exception Handling & Error Traps (Java)**
