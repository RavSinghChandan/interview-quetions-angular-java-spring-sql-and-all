Locked âœ…
Proceeding with **Topic 9** in the **same colorful `.md`**, **strict DSA**, **screen-share interviewâ€“ready** format.

---

## ğŸ“„ **File name:** `java-concurrent-collections-dsa.md`

# ğŸ§  **DSA Questions â€“ Concurrent Collections & Utilities (Java)**

*(Senior Backend | Uber / Enterprise Java â€“ Rule-Breaking Cases)*

> âš ï¸ Focus: **thread safety, performance trade-offs, and real production behavior**.

---

## ğŸ¯ DSA 1 â€” Rule break: `ConcurrentHashMap`â€”null not allowed

```java
Map<String, String> map = new ConcurrentHashMap<>();
map.put("key", null);
```

**Answer:**

```
NullPointerException
```

**Explanation:**
CHM disallows null to avoid ambiguity (get returns null = absent or null value?). Rule "Map allows null value" breaks.

---

## ğŸ¯ DSA 2 â€” Rule break: `ConcurrentHashMap` iteration is weakly consistent

```java
Map<Integer, Integer> map = new ConcurrentHashMap<>();
map.put(1, 1);
for(Integer k : map.keySet()) {
    map.put(2, 2);  // No CME
}
// May or may not see new entry
```

**Answer:**

```
No ConcurrentModificationException; may miss updates
```

**Explanation:**
Iterator is weakly consistentâ€”may reflect some concurrent updates. Rule "iteration = snapshot" breaks.

---

## ğŸ¯ DSA 3 â€” Rule break: `computeIfAbsent`â€”recursive modification

```java
Map<String, Integer> map = new ConcurrentHashMap<>();
map.computeIfAbsent("a", k -> {
    map.put("b", 1);  // Modifying during compute
    return 2;
});
```

**Answer:**

```
Can deadlock or throw
```

**Explanation:**
Modifying map during computeIfAbsent can cause deadlock (Java 8) or CME. Rule "compute is safe" breaks with reentrant modification.

---

## ğŸ¯ DSA 4 â€” Rule break: `CopyOnWriteArrayList`â€”iterator doesn't see adds

```java
List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(1, 2));
for(Integer i : list) {
    list.add(3);
}
// Iterator won't see the 3s added during iteration
```

**Answer:**

```
Iterator sees [1, 2] only
```

**Explanation:**
Iterator uses snapshot; adds during iteration not visible. Rule "iteration sees all" breaks for COW.

---

## ğŸ¯ DSA 5 â€” Rule break: `BlockingQueue.take`â€”blocks forever if empty

```java
BlockingQueue<Integer> q = new LinkedBlockingQueue<>();
q.take();  // Blocks until element available
```

**Answer:**

```
Blocks indefinitely
```

**Explanation:**
take() blocks; no timeout. Rule "take returns when empty" breaksâ€”it blocks. Use poll(timeout).

---

## ğŸ¯ DSA 6 â€” Rule break: `ArrayBlockingQueue` vs `LinkedBlockingQueue`â€”bounded vs unbounded

```java
BlockingQueue<Integer> q = new LinkedBlockingQueue<>();  // Unbounded
q = new LinkedBlockingQueue<>(10);  // Bounded
q = new ArrayBlockingQueue<>(10);  // Always bounded
```

**Answer:**

```
Different default capacity
```

**Explanation:**
LinkedBlockingQueue can be unbounded; ArrayBlockingQueue always bounded. Rule "BlockingQueue is bounded" breaks for unbounded LBlockingQueue.

---

## ğŸ¯ DSA 7 â€” Rule break: `AtomicInteger`â€”check-then-act is not atomic

```java
AtomicInteger i = new AtomicInteger(0);
if (i.get() < 10) {
    i.incrementAndGet();  // Race: another thread can increment between get and increment
}
```

**Answer:**

```
Can exceed 10
```

**Explanation:**
get + incrementAndGet is not atomic. Use compareAndSet or updateAndGet. Rule "Atomic = atomic compound ops" breaks.

---

## ğŸ¯ DSA 8 â€” Rule break: ABA problem with CAS

```java
AtomicReference<Integer> ref = new AtomicReference<>(100);
// Thread 1: ref.compareAndSet(100, 101)
// Thread 2: ref.compareAndSet(100, 99); ref.compareAndSet(99, 100)
// Thread 1 CAS can succeed even though value changed
```

**Answer:**

```
CAS succeeds despite intermediate change
```

**Explanation:**
ABA: Aâ†’Bâ†’A; CAS sees A and succeeds. Use AtomicStampedReference if ABA matters. Rule "CAS detects change" breaks for ABA.

---

## ğŸ¯ DSA 9 â€” Rule break: `ReentrantLock`â€”must unlock in finally

```java
lock.lock();
doWork();  // If exception, lock never released
lock.unlock();
```

**Answer:**

```
Lock never released on exception
```

**Explanation:**
unlock must be in finally. Rule "lock protects block" breaks if unlock skipped on exception.

---

## ğŸ¯ DSA 10 â€” Rule break: `Executors.newCachedThreadPool`â€”unbounded

```java
ExecutorService exec = Executors.newCachedThreadPool();
for(int i = 0; i < 1_000_000; i++) {
    exec.submit(() -> {});
}
// Can create millions of threads
```

**Answer:**

```
OutOfMemoryError or system crash
```

**Explanation:**
CachedThreadPool creates threads on demand; unbounded. Rule "ExecutorService limits threads" breaks for CachedThreadPool.

---

## ğŸ¯ DSA 11 â€” Rule break: `Future.get`â€”blocks

```java
Future<?> f = exec.submit(() -> { Thread.sleep(10000); });
f.get();  // Blocks 10 seconds
```

**Answer:**

```
Calling thread blocked
```

**Explanation:**
get() blocks until completion. Rule "submit is async" holds, but get() is sync. Use get(timeout).

---

## ğŸ¯ DSA 12 â€” Rule break: `ScheduledExecutorService`â€”delay is from task START

```java
scheduler.scheduleAtFixedRate(task, 0, 1, SECONDS);
// If task takes 2s, next run starts 2s after previous START, not 1s after END
```

**Answer:**

```
Overlapping executions if task > period
```

**Explanation:**
Fixed-rate schedules from start of previous run. Rule "fixed rate = predictable" breaks when task exceeds period.

---

## ğŸŒŸ Why this topic matters

* Backend uses **thread pools and concurrent collections**
* Wrong choices cause **deadlocks, leaks, or OOM**
* Interviewers expect **production-grade concurrency**

---

### â–¶ï¸ Next step

Reply with **`10`** to continue:

## ğŸ”¥ **Exception Handling & Error Traps**

Same colorful `.md`, same strict DSA interview format.
