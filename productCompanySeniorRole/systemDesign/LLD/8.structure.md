Great. Now we continue with **STEP 8 — structural-patterns.md**
This section is extremely important because **structural patterns are heavily used in real production systems**, especially in fintech, large-scale backend, and platform engineering — exactly the level your target companies expect.

We will cover **ALL 7 GoF Structural Patterns** in full senior-level detail.

---


# STEP 8 — STRUCTURAL PATTERNS (ARCHITECTURE SHAPING)

Structural patterns solve:

How objects are composed together to form larger structures.

If creational patterns answer:
"How to create objects?"

Structural patterns answer:
"How should objects be connected?"

Interviewers use this section to test:
- architecture maturity
- extensibility thinking
- system composition skill

---

# THE 7 STRUCTURAL PATTERNS (ALL)

1. Adapter
2. Bridge
3. Composite
4. Decorator
5. Facade
6. Flyweight
7. Proxy

You must recognize when each is needed.

---

---

# 1️⃣ ADAPTER PATTERN

Purpose:
Make incompatible interfaces work together.

Think:
Translator.

---

Problem:
Two systems speak different formats.

Solution:
Adapter converts one interface into another.

---

Real Example:
Payment gateway wrapper for third-party APIs.

---

When to Use
- legacy system integration
- third-party APIs
- library mismatch

---

Senior Insight
Adapters isolate external dependencies.

---

---

# 2️⃣ BRIDGE PATTERN

Purpose:
Separate abstraction from implementation.

So both can evolve independently.

---

Example:

RemoteControl abstraction  
TV / AC implementations  

Remote shouldn’t depend on device type.

---

When to Use
When abstraction and implementation may change independently.

---

Difference vs Adapter

Adapter → makes things compatible  
Bridge → separates concerns

---

---

# 3️⃣ COMPOSITE PATTERN

Purpose:
Treat single objects and groups uniformly.

---

Example:

File system

File  
Folder → contains Files or Folders  

Both share interface.

---

Use Cases
- tree structures
- hierarchies
- nested systems

---

Senior Insight
Composite simplifies recursive logic.

---

---

# 4️⃣ DECORATOR PATTERN

Purpose:
Add behavior dynamically without modifying class.

---

Example:

Coffee + Milk + Sugar + Cream

Each add-on wraps base object.

---

Used For
- middleware
- logging layers
- validation layers
- security filters

---

Decorator vs Inheritance

Inheritance → static behavior  
Decorator → runtime behavior

---

---

# 5️⃣ FACADE PATTERN

Purpose:
Provide simple interface to complex subsystem.

---

Example:

BookingFacade

Internally calls:
- payment
- seat
- notification
- ticketing

User sees ONE method.

---

When to Use
When subsystem is complex and you want simple API.

---

Senior Insight
Facade improves usability and reduces coupling.

---

---

# 6️⃣ FLYWEIGHT PATTERN

Purpose:
Reduce memory usage by sharing objects.

---

Example:

Text editor characters.

Instead of storing same font data repeatedly,
share it.

---

Used When
- many similar objects
- memory critical systems
- game engines
- rendering systems

---

Interview Signal
Mention Flyweight → interviewer knows you understand memory optimization.

---

---

# 7️⃣ PROXY PATTERN

Purpose:
Control access to an object.

Proxy sits between client and real object.

---

Types of Proxy

- Virtual Proxy → lazy loading
- Security Proxy → access control
- Remote Proxy → remote calls
- Logging Proxy → logging wrapper
- Cache Proxy → caching layer

---

Real Examples

- ORM lazy loading
- API gateway auth layer
- network request wrapper

---

---

# STRUCTURAL PATTERN SELECTION GUIDE

If problem is…

Incompatible interface → Adapter  
Abstraction & implementation must vary → Bridge  
Tree structure → Composite  
Add behavior dynamically → Decorator  
Complex subsystem → Facade  
Memory optimization → Flyweight  
Controlled access → Proxy  

---

---

# COMMON INTERVIEW CONFUSIONS

Know these differences:

Decorator vs Proxy
Decorator adds behavior  
Proxy controls access  

Adapter vs Facade
Adapter converts interface  
Facade simplifies interface  

Composite vs Decorator
Composite = tree structure  
Decorator = layered behavior

---

---

# SENIOR DESIGN SIGNALS

Mentioning structural patterns shows:

- system experience
- architectural thinking
- scalability awareness
- maintainability focus

---

---

# STRUCTURAL DESIGN CHECKLIST

Before finishing design ask:

✔ Is structure flexible?  
✔ Can parts change independently?  
✔ Is coupling minimized?  
✔ Is memory efficient?  
✔ Can behavior be added dynamically?  

---

---

# REAL INTERVIEW EXAMPLE

Design Notification Platform.

Possible patterns:

Facade → simple send() API  
Decorator → add logging + retry  
Adapter → integrate third-party provider  
Proxy → rate limit calls  

Senior candidates combine patterns.

---

---

# ADVANCED INSIGHT (VERY FEW CANDIDATES KNOW)

Real systems rarely use one pattern.

They use combinations.

Example:

Facade + Adapter + Decorator + Proxy

Layered architecture = pattern composition.

---

---

# INTERVIEW POWER SENTENCE

Say:

"I can wrap this with a decorator later if we need additional behavior."

Interviewer immediately recognizes depth.

---

---

# PRACTICE TASK

Identify structural pattern usage in:

- API Gateway
- Logging framework
- ORM
- Spring Security filter chain
- HTTP middleware

---

---

# FINAL PRINCIPLE

Creational patterns build objects.  
Structural patterns build architecture.
```

---

✅ Next file will be
**STEP 9 — behavioral-patterns.md**
This is the biggest one — **all 11 behavioral patterns** and extremely important for senior interviews because they test how systems behave, communicate, and coordinate logic.

Reply **9** when ready.
